\documentclass[a4paper, 12pt]{scrartcl}

\usepackage[T1]{fontenc}
%\usepackage[utf8]{inputenc}
\usepackage{fontspec}
\usepackage[ngerman]{babel}
\usepackage{setspace}
\usepackage{fancyhdr}
\usepackage{titling}
\usepackage{titlesec}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage[stable]{footmisc}

\usepackage[hidelinks]{hyperref}

%\usepackage[modulo]{lineno}
\usepackage{lineno}

\usepackage{tikz}
\usepackage{tikz-uml}
\usetikzlibrary{positioning}

\pagestyle{fancy}

\fancyhf{}
\fancyhead[L]{}
\fancyhead[C]{\emph{\nouppercase\rightmark}}
\fancyhead[R]{}
\fancyfoot[C]{\thepage}

\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

\renewcommand{\familydefault}{\rmdefault}

\addtokomafont{labelinglabel}{\sffamily}

%\renewcommand{\maketitle}{
%  \begin{center}
%    {\huge \bfseries \thetitle}\\
%    \vspace{.25em}
%    {\Large \theauthor}
%  \end{center}
%}

\titleformat{\section}
{\Large \bfseries}
{\thesection \ }
{0em}
{}[\titlerule]

\titleformat{\subsection}
{\large \bfseries}
{\thesubsection \ }
{0em}
{}

\titleformat{\subsubsection}[runin]
{\bfseries}
{}
{0em}
{}

\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
language=Java,
numbers=left,
aboveskip=3mm,
belowskip=3mm,
showstringspaces=false,
columns=flexible,
basicstyle={\small\ttfamily},
numberstyle=\tiny\color{gray},
keywordstyle=\color{blue},
commentstyle=\color{dkgreen},
stringstyle=\color{mauve},
breaklines=true,
breakatwhitespace=true,
tabsize=3
}

\title{39. Bundeswettbewerb Informatik, 1. Runde}
\author{Jan Ehehalt, Jonathan Hager}
\date{}

\begin{document}
\maketitle
\thispagestyle{empty}
\newpage
\tableofcontents
\thispagestyle{empty}
\newpage

\section{Wörter aufräumen}
\subsection{Lösungsidee}

Es werden zwei Listen angelegt, die jeweils alle Lücken und alle vollständigen Wörter getrennt speichern. Das Programm geht die Liste der Lücken durch und fügt für jede Lücke, der sich nur ein Wort eindeutig zuordnen lässt, das entsprechende Wort ein. Dieser Durchlauf wird so oft wiederholt, bis entweder alle Lücken gefüllt sind, oder in einem Durchlauf kein Wort mehr eingefügt werden konnte. Diese Lücken müssen anhand der Länge dem entsprechenden Wort zugeordnet werden. Dieses Verfahren muss funktionieren, da in jede Lücke nur ein Wort passen kann.  

\subsection{Umsetzung}


\section{Dreieckspuzzle}
\section{Tobis Turnier}
\section{Streichholzrätsel}
Im Folgenden sieht man ein Codebeispiel für Code, der beispielhaft geschrieben wurde.

\begin{lstlisting}
// Kommentare sind ne geile Sache
import com.badlogic.ShitRenderer;

public static void main(String[] args){
    Controller.control(theWorld);
    Math.atan(1/0);
}
\end{lstlisting}

Im Codebeispiel sieht man, wie der JavaScript Compiler intern arbeitet. Besondere Achtung sollte hierbei dem Math-Befehl gegeben werden, denn Math wurde nicht importiert und deshalb crasht es bereits deshalb, nicht wegen der ZeroDivision, da JavaScript hier einfach das Ergebnis würfeln wurde. \# Ehre

\section{Wichteln}
\subsection{Lösungsidee}

Im Wesentlichen ist das Problem der Zuordnung mit dem \emph{Stable Marriage Problem} vergleichbar. Es gibt zwei verschiedene Gruppen, die so gut wie möglich verteilt werden müssen. Deshalb lässt sich die Aufgabe mit einer leicht angepassten Variante des \emph{Gale-Shapley} Algorithmus lösen. Allgemein fragen alle Schüler ohne Geschenk bei den Geschenken an, ob diese noch keinen Partner haben oder den neuen Partner dem aktuellen vorziehen. Dabei wird ein Erstwunsch allem vorgezogen, dann folgen Zweitwunsch, Drittwunsch und zuletzt eine Zuteilung ohne Wunsch. Jeder Schüler fragt nacheinander seine Wünsche an. Sollte er danach noch kein Geschenk haben, versucht er ein übriges Geschenk zu bekommen.

\subsection{Umsetzung}

\begin{figure}[h]
    \centering
    \begin{tikzpicture} 
        \umlclass{Student}{
            hasGift: boolean\\
            index: int\\
            presentId: int\\
            wishes: int[]\\
            asked: boolean[]
        }{
            Student(int[], int, int)\\
            requestPresent(Present[], Student[], int, int): void
        }
    \end{tikzpicture}
    \caption{Die Klasse \emph{Student}}
\end{figure}

Jeder Schüler wird durch ein Objekt der Klasse \emph{Student} repräsentiert. Dabei muss jeder Schüler speichern, ob er bereits ein Geschenk hat. Zudem weiß jeder Schüler, welche Geschenk er als Erst-, Zweit- und Drittwunsch will. Für den Algorithmus ist es notwendig, dass jeder Schüler zusätzlich seine Position im Array und alle Geschenke, die er schon versucht hat zu bekommen, kennt. Der Schüler braucht \emph{requestPresent()} als einzige Methode. Übergeben bekommt er zum einen den \emph{Present} und \emph{Student} Array, zum anderen den Index des entsprechenden Geschenks, sowie den Grad des Wunsches. Hierbei hat ein Erstwunsch den Grad 0, ein Zweitwunsch 1, ein Drittwunsch 2 und eine reine Zuteilung 3. Diesen Grad braucht das Geschenk, um den neuen Schüler mit dem möglicherweise aktuellen Schüler zu vergleichen und zu ermitteln, welchen Schüler es bevorzugt.

\begin{figure}[h]
    \centering
    \begin{tikzpicture} 
        \umlclass{Present}{
            studentId: int\\
            wish: int
        }{
            Present()\\
            changeStudent(students: Student[], wish: int, studentId: int): boolean
        }
    \end{tikzpicture}
    \caption{Die Klasse \emph{Present}}
\end{figure}

Die Geschenke werden von der Klasse \emph{Present} repräsentiert. Ein Geschenk muss hierfür wissen, an welchen Schüler es vergeben ist. Dazu wird der Index des Schülers gespeichert. Um zwei Schüler vergleichen zu können, muss zudem bekannt sein, welchen Grad der Wunsch des aktuellen Schülers hat. Dieser wird als \emph{int} gespeichert. Damit der Algorithmus funktioniert, muss das Geschenk seinen Schüler wechseln können. Hierfür wird der \emph{Student} Array übergeben, sowie der Grad des Wunsches vom neuen Schüler und der Index des neuen Schülers. Die Methode gibt durch einen \emph{boolean} zurück, ob der übergebene Schüler übernommen oder abgelehnt wurde. Die Methode arbeitet wie folgt:
\\
\begin{figure}[h]
\centering
\begin{lstlisting}
boolean changeStudent(Student[] students, int wish, int studentId) {
	if(this.wish > wish){
		if(this.studentId >= 0) {
			students[this.studentId].hasGift = false;
		}

		this.studentId = studentId;
		this.wish = wish;
		students[studentId].hasGift = true;
			
		return true;
	}
	else {
		return false;
	}
}
\end{lstlisting}
\caption{Die Methode \emph{changeStudent()}}
\end{figure}

Zuerst wird verglichen, ob der Grad des gespeicherten Wunsches größer ist, als der des neuen Schülers. Ein kleinerer Grad ist immer einem größeren vorzuziehen. Ist der Grad des neuen Wunsches also nicht echt kleiner als der bisherige, gibt die Methode direkt \emph{false} zurück, da der neue Schüler abgelehnt wird. Andernfalls soll der neue Schüler jedoch den alten ersetzen. Hierfür wird dem alten Schüler erst mitgeteilt, dass er kein Geschenk mehr hat. Davor muss geprüft werden, ob es überhaupt einen alten Schüler gibt. Gibt es keinen, hat \emph{studentId} den Standardwert -1, weshalb dieser Fall abgefangen werden muss. Anschließend werden die Werte des neuen Schülers übernommen, ihm wird mitgeteilt, dass er nun ein Geschenk hat und die Methode gibt \emph{true} zurück.

%\begin{linenumbers}\resetlinenumber
%\end{linenumbers}

\end{document}
