\documentclass[a4paper, 12pt]{scrartcl}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage{fontspec}
\usepackage[ngerman]{babel}
\usepackage{setspace}
\usepackage{fancyhdr}
\usepackage{titling}
\usepackage{titlesec}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage[stable]{footmisc}
\usepackage{booktabs}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{ucs} % Einige Unicode Zeichen

% Ein paar Mathe Sachen
\usepackage{amsmath,amssymb,amstext,mathtools}

\usepackage[hidelinks]{hyperref}
%\usepackage{hyperref}

%\usepackage[modulo]{lineno}
\usepackage{lineno}

\usepackage{tikz}
\usepackage{tikz-uml}
\usetikzlibrary{positioning}
\usetikzlibrary{graphs}

\pagestyle{fancy}

\fancyhf{}
\fancyhead[L]{}
\fancyhead[C]{\emph{\nouppercase\rightmark}}
\fancyhead[R]{}
\fancyfoot[C]{\thepage}

\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

\renewcommand{\familydefault}{\rmdefault}

\addtokomafont{labelinglabel}{\sffamily}

%\renewcommand{\maketitle}{
%  \begin{center}
%    {\huge \bfseries \thetitle}\\
%    \vspace{.25em}
%    {\Large \theauthor}
%  \end{center}
%}

\titleformat{\section}
{\Large \bfseries}
{\thesection \ }
{0em}
{}[\titlerule]

\titleformat{\subsection}
{\large \bfseries}
{\thesubsection \ }
{0em}
{}

\titleformat{\subsubsection}[runin]
{\bfseries}
{}
{0em}
{}

\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
language=Java,
numbers=left,
aboveskip=3mm,
belowskip=3mm,
showstringspaces=false,
columns=flexible,
basicstyle={\small\ttfamily},
numberstyle=\tiny\color{gray},
keywordstyle=\color{blue},
commentstyle=\color{dkgreen},
stringstyle=\color{mauve},
breaklines=true,
breakatwhitespace=true,
tabsize=3
}

\title{Dokumentation zu den Aufgaben des 39. Bundeswettbewerbs Informatik, 1. Runde}
\author{von Jan Ehehalt, Jonathan Hager}
\date{}

\begin{document}
\maketitle
\thispagestyle{empty}
\newpage
\tableofcontents
\thispagestyle{empty}
\newpage

\section{Wörter aufräumen}
\subsection{Lösungsidee}

Es werden zwei Listen angelegt, die jeweils alle Lücken und alle vollständigen Wörter getrennt speichern. Das Programm geht die Liste der Lücken durch und fügt für jede Lücke, der sich nur ein Wort eindeutig zuordnen lässt, das entsprechende Wort ein. Dieser Durchlauf wird so oft wiederholt, bis entweder alle Lücken gefüllt sind, oder in einem Durchlauf kein Wort mehr eingefügt werden konnte. Diese Lücken müssen anhand der Länge dem entsprechenden Wort zugeordnet werden. Dieses Verfahren muss funktionieren, da in jede Lücke nur ein Wort passen kann.  

\subsection{Umsetzung}

\section{Dreieckspuzzle}

\begin{figure}[h]
    \centering
    \begin{subfigure}[t]{0.45\textwidth}
        \centering
    \begin{tikzpicture}[scale=1]
    %0
    \draw (-1,0) -- node[sloped,above]{1} (1,0); %mitte
    \draw (-1,0) -- node[sloped,above,rotate=180]{2} (0,1.73); %links
    \draw (1,0) -- node[sloped,above,rotate=180]{-2} (0,1.73); %rechts

    %1
    \draw (-2,-1.73) -- node[sloped,above]{1} (0,-1.73);
    \draw (-2,-1.73) -- node[sloped,above,rotate=180]{2} (-1,0);
    \draw (0,-1.73) -- node[sloped,above,rotate=180]{-2} (-1,0);

    %2
    \draw (-1,0) -- node[sloped,above,rotate=180]{1} (1,0);
    \draw (-1,0) -- node[sloped,above,rotate=0]{2} (0,-1.73);
    \draw (1,0) -- node[sloped,above,rotate=0]{-2} (0,-1.73);

    %3
    \draw (0,-1.73) -- node[sloped,above]{1} (2,-1.73);
    \draw (0,-1.73) -- node[sloped,above,rotate=180]{2} (1,0);
    \draw (2,-1.73) -- node[sloped,above,rotate=180]{-2} (1,0);

    %4
    \draw (-3,-3.46) -- node[sloped,above]{1} (-1,-3.46);
    \draw (-3,-3.46) -- node[sloped,above,rotate=180]{2} (-2,-1.73);
    \draw (-2,-1.73) -- node[sloped,above,rotate=180]{-2} (-1,-3.46);

    %5
    \draw (-2,-1.73) -- node[sloped,above,rotate=180]{1} (0,-1.73);
    \draw (-2,-1.73) -- node[sloped,above,rotate=0]{2} (-1,-3.46);
    \draw (0,-1.73) -- node[sloped,above,rotate=0]{-2} (-1,-3.46);

    %6
    \draw (-1,-3.46) -- node[sloped,above]{1} (1,-3.46);
    \draw (-1,-3.46) -- node[sloped,above,rotate=180]{2} (0,-1.73);
    \draw (1,-3.46) -- node[sloped,above,rotate=180]{-2} (0,-1.73);

    %7
    \draw (0,-1.73) -- node[sloped,above,rotate=180]{1} (2,-1.73);
    \draw (0,-1.73) -- node[sloped,above,rotate=0]{2} (1,-3.46);
    \draw (2,-1.73) -- node[sloped,above,rotate=0]{-2} (1,-3.46);

    %8
    \draw (1,-3.46) -- node[sloped,above]{1} (3,-3.46);
    \draw (1,-3.46) -- node[sloped,above,rotate=180]{2} (2,-1.73);
    \draw (3,-3.46) -- node[sloped,above,rotate=180]{-2} (2,-1.73);
    \end{tikzpicture}

        \subcaption{Das Puzzle}
    \end{subfigure}
\hfill
    \begin{subfigure}[t]{0.45\textwidth}
    \centering

    \begin{tikzpicture}
        \begin{scope}[every node/.style={circle,thick,draw}]
            \node (0) at (0,0) {0};
            \node (1) at (-1.5,-1.5) {1};
            \node (2) at (0,-1.5) {2};
            \node (3) at (1.5,-1.5) {3};
            \node (4) at (-3,-3) {4};
            \node (5) at (-1.5,-3) {5};
            \node (6) at (0,-3) {6};
            \node (7) at (1.5,-3) {7};
            \node (8) at (3,-3) {8};
        \end{scope}
        
        \begin{scope}
            %\path[-] (0) edge node[sloped,above]{Text} (2);
            \path[-] (0) edge (2);
            \path[-] (2) edge (1);
            \path[-] (2) edge (3);
            \path[-] (1) edge (5);
            \path[-] (4) edge (5);
            \path[-] (5) edge (6);
            \path[-] (6) edge (7);
            \path[-] (7) edge (3);
            \path[-] (7) edge (8);
        \end{scope}
    \end{tikzpicture}

        \subcaption{Als Graph}
    \end{subfigure}
    \caption{Geile Abbildung}
\end{figure}

\begin{figure}[h]
\end{figure}

\subsection{Lösungsidee}
\subsection{Umsetzung}
\subsection{Beispiele}

\section{Tobis Turnier}
\section{Streichholzrätsel}
Im Folgenden sieht man ein Codebeispiel für Code, der beispielhaft geschrieben wurde.

\begin{lstlisting}
// Kommentare sind ne geile Sache
import com.badlogic.ShitRenderer;

public static void main(String[] args){
    Controller.control(theWorld);
    Math.atan(1/0);
}
\end{lstlisting}

Im Codebeispiel sieht man, wie der JavaScript Compiler intern arbeitet. Besondere Achtung sollte hierbei dem Math-Befehl gegeben werden, denn Math wurde nicht importiert und deshalb crasht es bereits deshalb, nicht wegen der ZeroDivision, da JavaScript hier einfach das Ergebnis würfeln wurde. \# Ehre

\section{Wichteln}
\subsection{Lösungsidee}

Im Wesentlichen ist das Problem der Zuordnung mit dem \emph{Stable Marriage Problem} vergleichbar. Es gibt zwei verschiedene Gruppen, die so gut wie möglich verteilt werden müssen. Deshalb lässt sich die Aufgabe mit einer leicht angepassten Variante des \emph{Gale-Shapley} Algorithmus lösen. Allgemein fragen alle Schüler ohne Geschenk bei den Geschenken an, ob diese noch keinen Partner haben oder den neuen Partner dem aktuellen vorziehen. Dabei wird ein Erstwunsch allem vorgezogen, dann folgen Zweitwunsch, Drittwunsch und zuletzt eine Zuteilung ohne Wunsch. Jeder Schüler fragt nacheinander seine Wünsche an. Sollte er danach noch kein Geschenk haben, versucht er ein übriges Geschenk zu bekommen.

\subsection{Umsetzung}

\begin{figure}[h]
    \centering
    \begin{tikzpicture} 
        \umlclass{Student}{
            hasGift: boolean\\
            index: int\\
            presentId: int\\
            wishes: int[]\\
            asked: boolean[]
        }{
            Student(int[], int, int)\\
            requestPresent(Present[], Student[], int, int): void
        }
    \end{tikzpicture}
    \caption{Die Klasse \emph{Student}}
\end{figure}

Jeder Schüler wird durch ein Objekt der Klasse \emph{Student} repräsentiert. Dabei muss jeder Schüler speichern, ob er bereits ein Geschenk hat. Zudem weiß jeder Schüler, welche Geschenk er als Erst-, Zweit- und Drittwunsch will. Für den Algorithmus ist es notwendig, dass jeder Schüler zusätzlich seine Position im Array und alle Geschenke, die er schon versucht hat zu bekommen, kennt. Der Schüler braucht \emph{requestPresent()} als einzige Methode. Übergeben bekommt er zum einen den \emph{Present} und \emph{Student} Array, zum anderen den Index des entsprechenden Geschenks, sowie den Grad des Wunsches. Hierbei hat ein Erstwunsch den Grad 0, ein Zweitwunsch 1, ein Drittwunsch 2 und eine reine Zuteilung 3. Diesen Grad braucht das Geschenk, um den neuen Schüler mit dem möglicherweise aktuellen Schüler zu vergleichen und zu ermitteln, welchen Schüler es bevorzugt.

\begin{figure}[h]
    \centering
    \begin{tikzpicture} 
        \umlclass{Present}{
            studentId: int\\
            wish: int
        }{
            Present()\\
            changeStudent(students: Student[], wish: int, studentId: int): boolean
        }
    \end{tikzpicture}
    \caption{Die Klasse \emph{Present}}
\end{figure}

Die Geschenke werden von der Klasse \emph{Present} repräsentiert. Ein Geschenk muss hierfür wissen, an welchen Schüler es vergeben ist. Dazu wird der Index des Schülers gespeichert. Um zwei Schüler vergleichen zu können, muss zudem bekannt sein, welchen Grad der Wunsch des aktuellen Schülers hat. Dieser wird als \emph{int} gespeichert. Damit der Algorithmus funktioniert, muss das Geschenk seinen Schüler wechseln können. Hierfür wird der \emph{Student} Array übergeben, sowie der Grad des Wunsches vom neuen Schüler und der Index des neuen Schülers. Die Methode gibt durch einen \emph{boolean} zurück, ob der übergebene Schüler übernommen oder abgelehnt wurde. Die Methode arbeitet wie folgt:

\begin{figure}[h]
\centering
\begin{lstlisting}
boolean changeStudent(Student[] students, int wish, int studentId) {
	if(this.wish > wish){
		if(this.studentId >= 0) {
			students[this.studentId].hasGift = false;
		}

		this.studentId = studentId;
		this.wish = wish;
		students[studentId].hasGift = true;
			
		return true;
	}
	else {
		return false;
	}
}
\end{lstlisting}
\caption{Die Methode \emph{changeStudent()}}
\end{figure}

Zuerst wird verglichen, ob der Grad des gespeicherten Wunsches größer ist, als der des neuen Schülers. Ein kleinerer Grad ist immer einem größeren vorzuziehen. Ist der Grad des neuen Wunsches also nicht echt kleiner als der bisherige, gibt die Methode direkt \emph{false} zurück, da der neue Schüler abgelehnt wird. Andernfalls soll der neue Schüler jedoch den alten ersetzen. Hierfür wird dem alten Schüler erst mitgeteilt, dass er kein Geschenk mehr hat. Davor muss geprüft werden, ob es überhaupt einen alten Schüler gibt. Gibt es keinen, hat \emph{studentId} den Standardwert -1, weshalb dieser Fall abgefangen werden muss. Anschließend werden die Werte des neuen Schülers übernommen, ihm wird mitgeteilt, dass er nun ein Geschenk hat und die Methode gibt \emph{true} zurück. Der Algorithmus selbst ist in zwei Phasen unterteilt:
\begin{enumerate}
    \item Jeder Schüler versucht seinen Erstwunsch zu bekommen.
    \item Jeder Schüler fragt pro Durchlauf ein Geschenk, dass er noch nicht versucht hat, an. Hierbei werden nacheinander die Wünsche favorisiert. Sind bereits alle probiert wurden, werden einfach alle restlichen Geschenke versucht.
\end{enumerate}
Phase 1 findet nur beim ersten Durchlauf durch alle Schüler statt. Danach wird in Phase 2 übergegangen und solang über alle Schüler iteriert, bis jeder ein Geschenk bekommen hat. Endet die Schleife, wurde die bestmögliche Verteilung erreicht. Der gesamte Quellcode des Algorithmus ist in Abbildung \ref{AlgWichteln} zu finden.

\begin{figure}[h]
    \centering
\begin{lstlisting}
// Phase 1
for(int i=0; i<students.length; i++) {
    students[i].requestPresent(presents, students, students[i].wishes[0], 0);
}
            
// Phase 2
boolean finished = false;
do {
    // Die Schleife ist prinzipiell immer fertig, außer es wird noch ein Schüler gefunden, der kein Geschenk hat
    finished = true;
    for(int i = 0; i < students.length; i++) {
        if(!students[i].hasGift) {
            finished = false;
            			
            // Es wird versucht, einen der Wünsche zu erfüllen
            if(!students[i].asked[students[i].wishes[0]]) {
            	students[i].requestPresent(presents, students, students[i].wishes[0], 0);
            } else if(!students[i].asked[students[i].wishes[1]]) {
            	students[i].requestPresent(presents, students, students[i].wishes[1], 1);
            } else if(!students[i].asked[students[i].wishes[2]]) {
            	students[i].requestPresent(presents, students, students[i].wishes[2], 2);
            } else {
                // Da bereits alle Wünsche probiert wurden, wird versucht irgendein Geschenk zu bekommen
            	for(int j = 0; j < presents.length; j++) {
            	    if(!students[i].asked[j]) {
            	        students[i].requestPresent(presents, students, j, 3);
            	    }
                }
            }
        }
    }
} while(!finished);
    \end{lstlisting}
    \caption{Die Implementierung des Algorithmus\label{AlgWichteln}}
\end{figure}

\subsection{Beispiele}

Anhand eines selbsterstellten, kleinen Beispiels wird hier die Funktion des Algorithmus dargestellt. Anschließend werden alle Ergebnisse der vorgegebenen Beispielaufgaben aufgeführt.

\begin{table}[ht]
\centering

\begin{tabular}{@{}cccc@{}}
\toprule
Schüler & Erstwunsch & Zweitwunsch & Drittwunsch \\ \midrule
A       & 1          & 2           & 3           \\
B       & 2          & 3           & 4           \\
C       & 2          & 1           & 4           \\
D       & 4          & 1           & 3           \\ \bottomrule
\end{tabular}

\caption{Beispielhafte Verteilung der Wünsche\label{BeispielWichteln}}
\end{table}

Zuerst wird das Beispiel aus Tabelle \ref{BeispielWichteln} vom Programm eingelesen. Dabei wird für jeden Schüler, sowie für jedes Geschenk ein Objekt erstellt. Danach beginnt der Algorithmus direkt mit der Verteilung der Geschenke. Im ersten Durchlauf versucht jeder Schüler seinen Erstwunsch zu bekommen. Die Schleife beginnt mit Schüler A. Da sein Erstwunsch frei ist, bekommt er Geschenk 1 zugeteilt. Dasselbe passiert bei Schüler B, dieser bekommt folglich Geschenk 2 zugeteilt. Der Erstwunsch von Schüler C ist bereits vergeben und da C es mit einem Erstwunsch haben will, es aber bereits an einen Erstwunsch vergeben ist, wird Schüler C abgelehnt. Schüler D bekommt Geschenk 4 als Erstwunsch zugeteilt. Jetzt wird in Phase 2 gewechselt. Schüler A und B werden übersprungen, da beide bereits ein Geschenk haben. Schüler C hat seinen Erstwunsch bereits angefragt und probiert deshalb jetzt seinen Zweitwunsch. Dieser ist ebenfalls bereits vergeben und da Schüler C mit einem Zweitwunsch anfragt, wird er abgelehnt. D wird ebenfalls übersprungen. Im nächsten Durchlauf wird ebenfalls jeder außer C übersprungen. Dieser fragt nun seinen Drittwunsch an, welcher bereits an einen höheren Wunsch vergebenen ist. Somit beginnt erneut ein neuer Durchlauf der Schleife, bei dem C nun irgendein Geschenk, das er noch nicht probiert hat, versucht. Es bleibt nur Geschenk 3 übrig, welches er zugeteilt bekommt. Damit wurde jedem Schüler ein Geschenk zugeteilt. Die ausgegebene Verteilung lässt sich Tabelle \ref{WichtelnErgebnis} entnehmen.

\begin{table}[ht]
    \centering
\begin{tabular}{@{}cc@{}}
\toprule
\multicolumn{1}{l}{Schüler} & \multicolumn{1}{l}{Geschenk} \\ \midrule
A                           & 1                            \\
B                           & 2                            \\
C                           & 3                            \\
D                           & 4                            \\ \bottomrule
\end{tabular}

    \caption{Das Ergebnis des Programms\label{WichtelnErgebnis}}
\end{table}
%\begin{linenumbers}\resetlinenumber
%\end{linenumbers}

\end{document}
