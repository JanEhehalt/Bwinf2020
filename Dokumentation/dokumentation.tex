\documentclass[a4paper, 12pt]{scrartcl}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage{fontspec}
\usepackage[ngerman]{babel}
\usepackage{setspace}
\usepackage{fancyhdr}
\usepackage{titling}
\usepackage{titlesec}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage[stable]{footmisc}
\usepackage{booktabs}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{ucs} % Einige Unicode Zeichen

% Ein paar Mathe Sachen
\usepackage{amsmath,amssymb,amstext,mathtools}

\usepackage[hidelinks]{hyperref}
%\usepackage{hyperref}

%\usepackage[modulo]{lineno}
\usepackage{lineno}

\usepackage{tikz}
\usepackage{tikz-uml}
\usetikzlibrary{positioning}
\usetikzlibrary{graphs}

\pagestyle{fancy}

\fancyhf{}
\fancyhead[L]{}
\fancyhead[C]{\emph{\nouppercase\rightmark}}
\fancyhead[R]{}
\fancyfoot[C]{\thepage}

\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

\renewcommand{\familydefault}{\rmdefault}

\addtokomafont{labelinglabel}{\sffamily}

%\renewcommand{\maketitle}{
%  \begin{center}
%    {\huge \bfseries \thetitle}\\
%    \vspace{.25em}
%    {\Large \theauthor}
%  \end{center}
%}

\titleformat{\section}
{\Large \bfseries}
{\thesection \ }
{0em}
{}[\titlerule]

\titleformat{\subsection}
{\large \bfseries}
{\thesubsection \ }
{0em}
{}

\titleformat{\subsubsection}
{\bfseries}
{\thesubsubsection \ }
{0em}
{}

\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
language=Java,
numbers=left,
aboveskip=3mm,
belowskip=3mm,
showstringspaces=false,
columns=flexible,
basicstyle={\small\ttfamily},
numberstyle=\tiny\color{gray},
keywordstyle=\color{blue},
commentstyle=\color{dkgreen},
stringstyle=\color{mauve},
breaklines=true,
breakatwhitespace=true,
tabsize=3
}

\title{Dokumentation zu den Aufgaben des 39. Bundeswettbewerbs Informatik, 1. Runde}
\author{von Jan Ehehalt, Jonathan Hager}
\date{}

\begin{document}
\maketitle
\thispagestyle{empty}
\newpage
\tableofcontents
\thispagestyle{empty}
\newpage

\section{Allgemeine Informationen}

Da einige Methoden zu lang für eine Seite sind, wurde der Quellcode teilweise gekürzt. Die wichtigen Teile sind weiterhin enthalten. Auslassungen sind entsprechend mit {\glqq}[\dots]{\grqq} gekennzeichnet und mit einer kurzen Erklärung zur Funktion des ausgelassenen Codes versehen.

\section{Wörter aufräumen}
\subsection{Lösungsidee}

Es werden zwei Listen angelegt, die jeweils alle Lücken und alle vollständigen Wörter getrennt speichern. Das Programm geht die Liste der Lücken durch und fügt für jede Lücke, der sich nur ein Wort eindeutig zuordnen lässt, das entsprechende Wort ein. Dieser Durchlauf wird so oft wiederholt, bis entweder alle Lücken gefüllt sind, oder in einem Durchlauf kein Wort mehr eingefügt werden konnte. Diese Lücken müssen anhand der Länge dem entsprechenden Wort zugeordnet werden. Dieses Verfahren muss funktionieren, da in jede Lücke nur ein Wort passen kann.  

\subsection{Umsetzung}

\section{Dreieckspuzzle}
\subsection{Lösungsidee}

Ein Algorithmus soll durch systematisches Probieren alle sinnvollen Möglichkeiten testen. Das Programm legt erst das erste Puzzleteil, versucht dann dessen anliegende Kanten mit Teilen zu füllen. Sollte es für ein Puzzleteil keine verfügbaren Teile mehr geben, die an die Kante passen, geht der Algorithmus mittels Backtracking zurück. Sobald er wieder zu einem Teil kommt, bei dem er andere Teile noch nicht probiert hat, versucht er das Puzzle ab hier wieder neu aufzubauen.

\subsection{Umsetzung}

Zur Darstellung der Struktur des Puzzle wird ein ungerichteter und ungewichteter Graph verwendet. Der Aufbau wird in Abbildung \ref{Graph1} gezeigt.

\begin{figure}[h]
    \centering
    \begin{subfigure}[t]{0.45\textwidth}
        \centering
    \begin{tikzpicture}[scale=1]
    %0
    \draw (-1,0) -- node[sloped,above]{1} (1,0); %mitte
    \draw (-1,0) -- node[sloped,above,rotate=180]{2} (0,1.73); %links
    \draw (1,0) -- node[sloped,above,rotate=180]{-2} (0,1.73); %rechts

    %1
    \draw (-2,-1.73) -- node[sloped,above]{1} (0,-1.73);
    \draw (-2,-1.73) -- node[sloped,above,rotate=180]{2} (-1,0);
    \draw (0,-1.73) -- node[sloped,above,rotate=180]{-2} (-1,0);

    %2
    \draw (-1,0) -- node[sloped,above,rotate=180]{1} (1,0);
    \draw (-1,0) -- node[sloped,above,rotate=0]{2} (0,-1.73);
    \draw (1,0) -- node[sloped,above,rotate=0]{-2} (0,-1.73);

    %3
    \draw (0,-1.73) -- node[sloped,above]{1} (2,-1.73);
    \draw (0,-1.73) -- node[sloped,above,rotate=180]{2} (1,0);
    \draw (2,-1.73) -- node[sloped,above,rotate=180]{-2} (1,0);

    %4
    \draw (-3,-3.46) -- node[sloped,above]{1} (-1,-3.46);
    \draw (-3,-3.46) -- node[sloped,above,rotate=180]{2} (-2,-1.73);
    \draw (-2,-1.73) -- node[sloped,above,rotate=180]{-2} (-1,-3.46);

    %5
    \draw (-2,-1.73) -- node[sloped,above,rotate=180]{1} (0,-1.73);
    \draw (-2,-1.73) -- node[sloped,above,rotate=0]{2} (-1,-3.46);
    \draw (0,-1.73) -- node[sloped,above,rotate=0]{-2} (-1,-3.46);

    %6
    \draw (-1,-3.46) -- node[sloped,above]{1} (1,-3.46);
    \draw (-1,-3.46) -- node[sloped,above,rotate=180]{2} (0,-1.73);
    \draw (1,-3.46) -- node[sloped,above,rotate=180]{-2} (0,-1.73);

    %7
    \draw (0,-1.73) -- node[sloped,above,rotate=180]{1} (2,-1.73);
    \draw (0,-1.73) -- node[sloped,above,rotate=0]{2} (1,-3.46);
    \draw (2,-1.73) -- node[sloped,above,rotate=0]{-2} (1,-3.46);

    %8
    \draw (1,-3.46) -- node[sloped,above]{1} (3,-3.46);
    \draw (1,-3.46) -- node[sloped,above,rotate=180]{2} (2,-1.73);
    \draw (3,-3.46) -- node[sloped,above,rotate=180]{-2} (2,-1.73);
    \end{tikzpicture}

        \subcaption{Das Puzzle}
    \end{subfigure}
\hfill
    \begin{subfigure}[t]{0.45\textwidth}
    \centering

    \begin{tikzpicture}
        \begin{scope}[every node/.style={circle,thick,draw}]
            \node (0) at (0,0) {0};
            \node (1) at (-1.5,-1.5) {1};
            \node (2) at (0,-1.5) {2};
            \node (3) at (1.5,-1.5) {3};
            \node (4) at (-3,-3) {4};
            \node (5) at (-1.5,-3) {5};
            \node (6) at (0,-3) {6};
            \node (7) at (1.5,-3) {7};
            \node (8) at (3,-3) {8};
        \end{scope}
        
        \begin{scope}
            %\path[-] (0) edge node[sloped,above]{Text} (2);
            \path[-] (0) edge (2);
            \path[-] (2) edge (1);
            \path[-] (2) edge (3);
            \path[-] (1) edge (5);
            \path[-] (4) edge (5);
            \path[-] (5) edge (6);
            \path[-] (6) edge (7);
            \path[-] (7) edge (3);
            \path[-] (7) edge (8);
        \end{scope}
    \end{tikzpicture}

        \subcaption{Darstellung als Graph}
        \label{Graph1.1}
    \end{subfigure}
    \caption{Interne Speicherung der Puzzlestruktur}
    \label{Graph1}
\end{figure}

Die Knoten bilden die einzelnen Puzzleteile. Wenn eine Kante im Graph existiert, dann berühren sich die beiden Puzzleteile auch im Puzzle, es muss also an den Stellen geprüft werden, ob sie zusammenpassen. Das ist der Fall, wenn beispielsweise die rechte Kante des einen Teils addiert mit der linken Kante des anderen Teils 0 ergibt.

Im Folgenden wird erst auf die einzelnen Klassen und deren Funktion eingegangen, anschließend wird die Vorgehensweise des Algorithmus anhand von Zeichnungen erläutert.

\subsubsection{Klassen}
\begin{figure}[h]
    \centering
    \begin{tikzpicture} 
        \umlclass{Tile}{
            $+$ values: int[]\\
            $+$ flipped: boolean
        }{
            $+$ rotate(): void\\
            $+$ flip(): void
        }
    \end{tikzpicture}
    \caption{Die Klasse \emph{Tile}}
    \label{tile}
\end{figure}

Die Klasse \emph{Tile} (Abbildung \ref{tile}) repräsentiert ein Puzzleteil. Dazu müssen die drei Kantenwerte gespeichert werden. Dies geschieht durch den Array \emph{values}. Die Seiten haben die Indizes wie folgt: $0$: links, $1$ mitte, $2$ rechts. Zudem muss gespeichert werden, ob ein Tile geflippt ist oder nicht. Dies ist nur bei den Stellen $2$, $5$, $7$ im Graph der Fall. Wenn ein Tile geflippt wird, müssen die Werte der linken und rechten Seite getauscht werden. Zudem muss das Tile in die andere Richtung rotiert werden. Die \emph{rotate()} Methode rotiert das Tile einmal um $120^\circ$.

\begin{figure}[h]
    \centering
    \begin{tikzpicture} 
        \umlclass{Graph}{
            $-$ matrix: int[][]\\
            $-$ tiles: Tile[]\\
            $-$ puzzle: int[]
        }{
            $+$ Graph(tiles: Tile[])\\
            $+$ fillWithTiles(): boolean\\
            $-$ fillBorders(tile: int): boolean\\
            $-$ fit(indexTiles: int, indexMatrix: int, rotations: int): boolean\\
            \dots
        }
    \end{tikzpicture}
    \caption{Die Klasse \emph{Graph}}
\end{figure}

Der Graph speichert seine Adjazenzmatrix, die als Wert $-1$, $0$ und $1$ annehmen kann. $-1$ bedeutet, dass diese Kante nicht existiert. Das ist der Fall, wenn sich die zwei Teile im echten Puzzle nicht berühren können, z.B. die rechte Kante der $0$ und die untere Kante der $4$. Den Wert $0$ nimmt eine Kante an, wenn diese aktuell nicht auf beiden Seiten besetzt ist, z.B. wenn in Abbildung \ref{Graph1.1} Teil 5 fehlen würde, hätten die Kanten 4-5, 1-5 und 5-6 den Wert $0$. Der Wert $1$ bedeutet, dass die Kante besetzt ist. Ist das Puzzle gelöst, haben also alle Kanten den Wert $-1$ oder $1$. $0$ würde bedeuten, dass es noch eine Kante gibt, die besetzt werden muss. Der Graph speichert im \emph{Tile} Array alle Puzzleteile, die es gibt. Der puzzle-Array speichert die Position jedes Teils im Graphen. Ist das Teil nicht im Graphen, hat puzzle an der Stelle des Teils den Wert $-1$.

Es wurden bewusst nicht alle Methoden in das Klassendiagramm übernommen, die wichtigen Methoden sind allerdings vorhanden. Die restlichen Methoden sind zur Erklärung des Algorithmus nicht von Bedeutung, sie fügen beispielsweise eine Kante am Anfang ein oder setzen das Puzzle zurück.

\subsubsection{Algorithmus}

Die Methode \emph{fillWithTiles()} wird aufgerufen, um das Puzzle zu lösen. Diese geht über jedes Puzzleteil und versucht das Puzzle damit an Stelle $0$ im Graphen zu lösen. Dazu wird \emph{fillBorders(0)} aufgerufen. Für den Quellcode der Methode, siehe Abbildung \ref{fillWithTiles}.

\begin{figure}[h]
    \centering

\begin{lstlisting}
public boolean fillWithTiles() {
	for(int i = 0; i < this.tiles.length; i++) {
		// puzzle-Array wird zurueckgesetzt
		resetPuzzle();

        // Das Tile wird an die Stelle 0 im Graph gesetzt
        puzzle[i] = 0;
		
        if(fillBorders(0)) {
            // Puzzle wurde gelöst
            return true;
        }
        // [...] fillBorders() wird für jede Rotation des Tile wiederholt
    }
	return false;
}
\end{lstlisting}

    \caption{Die Methode \emph{fillWithTiles()}}
    \label{fillWithTiles}
\end{figure}

Die Methode \emph{fillBorders(int)} versucht alle Kanten, die an die übergebene Stelle im Graphen, anliegen, zu füllen. Ob alles besetzt werden konnte, lässt sich am Rückgabewert \emph{true} oder \emph{false} erkennen. Dazu wird erst über die entsprechende Zeile in der Adjazenzmatrix iteriert. Nur beim Wert $0$ ist noch keine Kante vorhanden, also wird jetzt für diese Kante ein passendes Teil gesucht. Ob eine Teil bereits probiert wurde, wird beim \emph{visited} Array geschaut. Dort wurde bereits die eigene Stelle und alle Teile, die im Graph sind, als \emph{true} markiert, damit diese nicht erneut probiert werden. Wenn ein passendes Teil gefunden wurde, wird dieses vorläufig eingefügt. Anschließend versucht dieses Teil seine Kanten zu füllen. Scheitert es, wird es entfernt und ein neues Teil gesucht. Ist es erfolgreich, geht die Methode zum nächsten Eintrag in der Zeile der Matrix und versucht diese ebenfalls zu füllen. Der Quellcode in Abbildung \ref{fillBorders} ist ein Teil der Methode. Dort wird zuerst mit \emph{fit()} überprüft, ob das Tile an die Stelle passt. Anschließend wird es dort eingefügt und versucht alle Kanten zu füllen, indem es \emph{fillBorders()} mit der eigenen Stelle im Graphen aufruft (\emph{puzzle} speichert für jedes Tile die Position im Graphen oder $-1$). $k$ ist das aktuelle Tile, $j$ die aktuelle Kante.

\begin{figure}[h]
    \centering

    \begin{lstlisting}
if(fit(k, j, 0)) {
	tileFound = true;
	resetTile(j);
	puzzle[k] = j;
	updateTrueLink(tile, j);
	placedTiles.add(j);
						
	if(fillBorders(puzzle[k])) {
		break;
	}
    else {
		resetTile(j);
		updateFalseLink(tile, j);
		tileFound = false;
	    continue;
    }
}
if(!tileFound) {
    // [...] alle vom Tile erstellten Tiles werden ebenfalls gelöscht
    return false;
}
return true;
    \end{lstlisting}

    \caption{Die Methode \emph{fillBorders}}
    \label{fillBorders}
\end{figure}

Die Methode \emph{fit()} prüft für eine gegebene Stelle im Graphen, ob ein gegebenes Puzzleteil passt. Zuerst wird geprüft, ob sich das Puzzleteil an der Stelle $2$, $5$ oder $7$ befindet. Ist dies der Fall, muss es geflippt werden. Im echten Puzzle äußert sich das an der Kante oben anstatt einer Spitze. Um zu wissen, welche Seiten bei zwei Teilen verglichen werden müssen, werden die beiden Stellen im Graph voneinander abgezogen. Kommt hier der Wert $-1$ raus, befindet sich das gefundene Teil rechts, bei $1$ links und bei jedem anderen Wert müssen die beiden mittleren Werte verglichen werden. Ist die Summe der beiden Kantenwerte der Teile $0$, passt das Puzzleteil. Der Quellcode, der eine Seite des Teils mit einer vorhandenen Kante vergleicht, ist in Abbildung \ref{fit} zu finden. $i$ ist der Index des zweiten Teils, mit dem verglichen werden muss.

\begin{figure}[h]
    \centering
\begin{lstlisting}
int difference = indexMatrix - i;
int side1 = 1;
int side2 = 1;
int tile2 = getIndexTiles(i);
			
if(difference == -1) {
    side1 = 2;
	side2 = 0;
}
else if(difference == 1) {
	side1 = 0;
	side2 = 2;
}	

if(tiles[indexTiles].values[side1] + tiles[tile2].values[side2] != 0) {
    fits = false;
    break;
}
\end{lstlisting}
    \caption{Ausschnitt von \emph{fit()}}
    \label{fit}
\end{figure}

\subsection{Beispiele}

\section{Tobis Turnier}
\section{Streichholzrätsel}
\section{Wichteln}
\subsection{Lösungsidee}

Im Wesentlichen ist das Problem der Zuordnung mit dem \emph{Stable Marriage Problem} vergleichbar. Es gibt zwei verschiedene Gruppen, die so gut wie möglich verteilt werden müssen. Deshalb lässt sich die Aufgabe mit einer leicht angepassten Variante des \emph{Gale-Shapley} Algorithmus lösen. Allgemein fragen alle Schüler ohne Geschenk bei den Geschenken an, ob diese noch keinen Partner haben oder den neuen Partner dem aktuellen vorziehen. Dabei wird ein Erstwunsch allem vorgezogen, dann folgen Zweitwunsch, Drittwunsch und zuletzt eine Zuteilung ohne Wunsch. Jeder Schüler fragt nacheinander seine Wünsche an. Sollte er danach noch kein Geschenk haben, versucht er ein übriges Geschenk zu bekommen.

\subsection{Umsetzung}

\begin{figure}[h]
    \centering
    \begin{tikzpicture} 
        \umlclass{Student}{
            hasGift: boolean\\
            index: int\\
            presentId: int\\
            wishes: int[]\\
            asked: boolean[]
        }{
            Student(int[], int, int)\\
            requestPresent(Present[], Student[], int, int): void
        }
    \end{tikzpicture}
    \caption{Die Klasse \emph{Student}}
\end{figure}

Jeder Schüler wird durch ein Objekt der Klasse \emph{Student} repräsentiert. Dabei muss jeder Schüler speichern, ob er bereits ein Geschenk hat. Zudem weiß jeder Schüler, welche Geschenk er als Erst-, Zweit- und Drittwunsch will. Für den Algorithmus ist es notwendig, dass jeder Schüler zusätzlich seine Position im Array und alle Geschenke, die er schon versucht hat zu bekommen, kennt. Der Schüler braucht \emph{requestPresent()} als einzige Methode. Übergeben bekommt er zum einen den \emph{Present} und \emph{Student} Array, zum anderen den Index des entsprechenden Geschenks, sowie den Grad des Wunsches. Hierbei hat ein Erstwunsch den Grad 0, ein Zweitwunsch 1, ein Drittwunsch 2 und eine reine Zuteilung 3. Diesen Grad braucht das Geschenk, um den neuen Schüler mit dem möglicherweise aktuellen Schüler zu vergleichen und zu ermitteln, welchen Schüler es bevorzugt.

\begin{figure}[h]
    \centering
    \begin{tikzpicture} 
        \umlclass{Present}{
            studentId: int\\
            wish: int
        }{
            Present()\\
            changeStudent(students: Student[], wish: int, studentId: int): boolean
        }
    \end{tikzpicture}
    \caption{Die Klasse \emph{Present}}
\end{figure}

Die Geschenke werden von der Klasse \emph{Present} repräsentiert. Ein Geschenk muss hierfür wissen, an welchen Schüler es vergeben ist. Dazu wird der Index des Schülers gespeichert. Um zwei Schüler vergleichen zu können, muss zudem bekannt sein, welchen Grad der Wunsch des aktuellen Schülers hat. Dieser wird als \emph{int} gespeichert. Damit der Algorithmus funktioniert, muss das Geschenk seinen Schüler wechseln können. Hierfür wird der \emph{Student} Array übergeben, sowie der Grad des Wunsches vom neuen Schüler und der Index des neuen Schülers. Die Methode gibt durch einen \emph{boolean} zurück, ob der übergebene Schüler übernommen oder abgelehnt wurde. Die Methode arbeitet wie folgt:

\begin{figure}[h]
\centering
\begin{lstlisting}
boolean changeStudent(Student[] students, int wish, int studentId) {
	if(this.wish > wish){
		if(this.studentId >= 0) {
			students[this.studentId].hasGift = false;
		}

		this.studentId = studentId;
		this.wish = wish;
		students[studentId].hasGift = true;
			
		return true;
	}
	else {
		return false;
	}
}
\end{lstlisting}
\caption{Die Methode \emph{changeStudent()}}
\end{figure}

Zuerst wird verglichen, ob der Grad des gespeicherten Wunsches größer ist, als der des neuen Schülers. Ein kleinerer Grad ist immer einem größeren vorzuziehen. Ist der Grad des neuen Wunsches also nicht echt kleiner als der bisherige, gibt die Methode direkt \emph{false} zurück, da der neue Schüler abgelehnt wird. Andernfalls soll der neue Schüler jedoch den alten ersetzen. Hierfür wird dem alten Schüler erst mitgeteilt, dass er kein Geschenk mehr hat. Davor muss geprüft werden, ob es überhaupt einen alten Schüler gibt. Gibt es keinen, hat \emph{studentId} den Standardwert -1, weshalb dieser Fall abgefangen werden muss. Anschließend werden die Werte des neuen Schülers übernommen, ihm wird mitgeteilt, dass er nun ein Geschenk hat und die Methode gibt \emph{true} zurück. Der Algorithmus selbst ist in zwei Phasen unterteilt:
\begin{enumerate}
    \item Jeder Schüler versucht seinen Erstwunsch zu bekommen.
    \item Jeder Schüler fragt pro Durchlauf ein Geschenk, dass er noch nicht versucht hat, an. Hierbei werden nacheinander die Wünsche favorisiert. Sind bereits alle probiert wurden, werden einfach alle restlichen Geschenke versucht.
\end{enumerate}
Phase 1 findet nur beim ersten Durchlauf durch alle Schüler statt. Danach wird in Phase 2 übergegangen und solang über alle Schüler iteriert, bis jeder ein Geschenk bekommen hat. Endet die Schleife, wurde die bestmögliche Verteilung erreicht. Der gesamte Quellcode des Algorithmus ist in Abbildung \ref{AlgWichteln} zu finden.

\begin{figure}[h]
    \centering
\begin{lstlisting}
// Phase 1
for(int i=0; i<students.length; i++) {
    students[i].requestPresent(presents, students, students[i].wishes[0], 0);
}
            
// Phase 2
boolean finished = false;
do {
    // Die Schleife ist prinzipiell immer fertig, außer es wird noch ein Schüler gefunden, der kein Geschenk hat
    finished = true;
    for(int i = 0; i < students.length; i++) {
        if(!students[i].hasGift) {
            finished = false;
            			
            // Es wird versucht, einen der Wünsche zu erfüllen
            if(!students[i].asked[students[i].wishes[0]]) {
            	students[i].requestPresent(presents, students, students[i].wishes[0], 0);
            } else if(!students[i].asked[students[i].wishes[1]]) {
            	students[i].requestPresent(presents, students, students[i].wishes[1], 1);
            } else if(!students[i].asked[students[i].wishes[2]]) {
            	students[i].requestPresent(presents, students, students[i].wishes[2], 2);
            } else {
                // Da bereits alle Wünsche probiert wurden, wird versucht irgendein Geschenk zu bekommen
            	for(int j = 0; j < presents.length; j++) {
            	    if(!students[i].asked[j]) {
            	        students[i].requestPresent(presents, students, j, 3);
            	    }
                }
            }
        }
    }
} while(!finished);
    \end{lstlisting}
    \caption{Die Implementierung des Algorithmus\label{AlgWichteln}}
\end{figure}

\subsection{Beispiele}

Anhand eines selbsterstellten, kleinen Beispiels wird hier die Funktion des Algorithmus dargestellt. Anschließend werden alle Ergebnisse der vorgegebenen Beispielaufgaben aufgeführt.

\begin{table}[ht]
\centering

\begin{tabular}{@{}cccc@{}}
\toprule
Schüler & Erstwunsch & Zweitwunsch & Drittwunsch \\ \midrule
A       & 1          & 2           & 3           \\
B       & 2          & 3           & 4           \\
C       & 2          & 1           & 4           \\
D       & 4          & 1           & 3           \\ \bottomrule
\end{tabular}

\caption{Beispielhafte Verteilung der Wünsche\label{BeispielWichteln}}
\end{table}

Zuerst wird das Beispiel aus Tabelle \ref{BeispielWichteln} vom Programm eingelesen. Dabei wird für jeden Schüler, sowie für jedes Geschenk ein Objekt erstellt. Danach beginnt der Algorithmus direkt mit der Verteilung der Geschenke. Im ersten Durchlauf versucht jeder Schüler seinen Erstwunsch zu bekommen. Die Schleife beginnt mit Schüler A. Da sein Erstwunsch frei ist, bekommt er Geschenk 1 zugeteilt. Dasselbe passiert bei Schüler B, dieser bekommt folglich Geschenk 2 zugeteilt. Der Erstwunsch von Schüler C ist bereits vergeben und da C es mit einem Erstwunsch haben will, es aber bereits an einen Erstwunsch vergeben ist, wird Schüler C abgelehnt. Schüler D bekommt Geschenk 4 als Erstwunsch zugeteilt. Jetzt wird in Phase 2 gewechselt. Schüler A und B werden übersprungen, da beide bereits ein Geschenk haben. Schüler C hat seinen Erstwunsch bereits angefragt und probiert deshalb jetzt seinen Zweitwunsch. Dieser ist ebenfalls bereits vergeben und da Schüler C mit einem Zweitwunsch anfragt, wird er abgelehnt. D wird ebenfalls übersprungen. Im nächsten Durchlauf wird ebenfalls jeder außer C übersprungen. Dieser fragt nun seinen Drittwunsch an, welcher bereits an einen höheren Wunsch vergebenen ist. Somit beginnt erneut ein neuer Durchlauf der Schleife, bei dem C nun irgendein Geschenk, das er noch nicht probiert hat, versucht. Es bleibt nur Geschenk 3 übrig, welches er zugeteilt bekommt. Damit wurde jedem Schüler ein Geschenk zugeteilt. Die ausgegebene Verteilung lässt sich Tabelle \ref{WichtelnErgebnis} entnehmen.

\begin{table}[ht]
    \centering
\begin{tabular}{@{}cc@{}}
\toprule
\multicolumn{1}{l}{Schüler} & \multicolumn{1}{l}{Geschenk} \\ \midrule
A                           & 1                            \\
B                           & 2                            \\
C                           & 3                            \\
D                           & 4                            \\ \bottomrule
\end{tabular}

    \caption{Das Ergebnis des Programms\label{WichtelnErgebnis}}
\end{table}
%\begin{linenumbers}\resetlinenumber
%\end{linenumbers}

\end{document}
