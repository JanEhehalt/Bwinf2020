\documentclass[a4paper, 12pt]{scrartcl}

\usepackage{dejavu}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage{fontspec}
\usepackage[ngerman]{babel}
\usepackage{setspace}
%\usepackage{fancyhdr}
\usepackage{titling}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage[stable]{footmisc}
\usepackage{booktabs}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{ucs} % Einige Unicode Zeichen
\usepackage[headsepline,footsepline]{scrlayer-scrpage}
\usepackage{titlesec}
\usepackage[a4paper]{geometry}
\geometry{verbose,tmargin=2.5cm,bmargin=2.5cm}

\usepackage{csquotes}
\MakeOuterQuote{"}

\usepackage{siunitx}
\sisetup{locale = DE}

% Fonts Fonts und noch mehr fonts
%\usepackage{kpfonts}
%\usepackage{fourier}

\usepackage{float}

% Ein paar Mathe Sachen
\usepackage{amsmath,amssymb,amstext,mathtools}

\usepackage[hidelinks]{hyperref}
%\usepackage{hyperref}

%\usepackage[modulo]{lineno}
\usepackage{lineno}

\usepackage{tikz}
\usepackage{tikz-uml}
\usetikzlibrary{positioning}
\usetikzlibrary{graphs}
\usetikzlibrary{arrows.meta}

\pagestyle{scrheadings}
\clearpairofpagestyles

\automark{section}
\ihead{Team-ID: $00441$}
\ohead{\headmark}
\cfoot[\pagemark]{\pagemark}

\renewcommand{\familydefault}{\rmdefault}

\addtokomafont{labelinglabel}{\sffamily}

\titleformat{\section}
{\Large \bfseries}
{\thesection \ }
{0em}
{}[\titlerule]

\titleformat{\subsection}
{\large \bfseries}
{\thesubsection \ }
{0em}
{}

\titleformat{\subsubsection}
{\bfseries}
{\thesubsubsection \ }
{0em}
{}

\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
language=Java,
numbers=left,
aboveskip=3mm,
belowskip=3mm,
showstringspaces=false,
columns=flexible,
basicstyle={\small\ttfamily},
numberstyle=\tiny\color{gray},
keywordstyle=\color{blue},
commentstyle=\color{dkgreen},
stringstyle=\color{mauve},
breaklines=true,
breakatwhitespace=true,
tabsize=3
}

\title{Dokumentation zu den Aufgaben des 39. Bundeswettbewerbs Informatik, 1. Runde}
\author{Jan Ehehalt, Jonathan Hager}
\date{}

\begin{document}
\thispagestyle{empty}
\begin{center}
	\setlength{\parskip}{2ex}
\rule{\textwidth}{.4pt}\par
{\huge\bfseries \thetitle \par}
\rule{\textwidth}{.4pt}\par
\bigbreak
{\Large \theauthor \par}
\end{center}
\newpage

\thispagestyle{empty}
\tableofcontents
\newpage

\section{Allgemeine Informationen}

Da einige Methoden zu lang für eine Seite sind, wurde der Quellcode teilweise gekürzt. Die wichtigen Teile sind weiterhin enthalten. Auslassungen sind entsprechend mit {\glqq}[\dots]{\grqq} gekennzeichnet und mit einer kurzen Erklärung zur Funktion des ausgelassenen Codes versehen.

\section{Wörter aufräumen}
\subsection{Lösungsidee}
Es werden zwei Listen  angelegt,  die  jeweils  alle  Lücken  und  alle  einzufügenden  Wörter  getrennt speichern.  Das  Programm  geht  dann  alle  Lücken  durch  und  fügt  für  jede  Lücke,  bei  der  bereits  ein Buchstabe gegeben ist, ein eindeutig zuzuordnendes Wort ein. Das Programm achtet hierbei darauf, dass der gegebene Buchstabe, mit dem im Wort übereinstimmt, und dass das Wort genauso lang ist wie die Lücke. Sollte für eine Lücke mehr als ein Wort potenziell passen, so wird diese Lücke vorerst übersprungen.  Dieses  Verfahren  wird  dann  so  oft  ausgeführt,  bis  entweder  alle  Lücken  gefüllt  sind oder alle noch leeren Lücken keinen gegebenen Buchstaben mehr haben. Sobald es keine gegebenen Buchstaben  mehr  gibt werden  die  restlichen  Wörter  noch  anhand ihrer  Länge  den  übrigen  Lücken zugeordnet. So gibt es am Ende keine leeren Lücken mehr.

\subsection{Umsetzung}
Jede Lücke wird im Array \emph{sentence} als String gespeichert. Hierbei werden sowohl die Lücken, welche aus {\glqq}\_{\grqq} und verschiedenen Buchstaben bestehen können, als auch die Satzeichen, als eigene Elemente im Array gespeichert. Der \emph{words} Array speichert die Wörter, die in den Satz eingefügt werden müssen. Dann wird eine Schleife gestartet, die nun den Lücken Array mit Elementen  aus  dem  \emph{words}  Array  füllen  soll. Um  zu  erkennen  welche  Lücken  bereits  gefüllt  wurden, wird ein Array aus \emph{booleans} erstellt, der speichert welche Lücke bereits gefüllt wurde. Die Satzzeichen werden  hier  automatisch von Beginn an auf \emph{true}  gesetzt,  da  sie  nicht  gefüllt  werden  müssen. Dann iteriert  das  Programm über  alle  Wörter  und zählt in  wie  viele  noch  nicht  gefüllte  Lücken  das  Wort anhand  des  gegebenen  Buchstaben  und  der Länge  passen würde.  Sollte  das  Wort  in  nur  eine  Lücke passen,  so wird es  auch  in  diese eingefügt und aus  dem  \emph{words}  Array  entfernt. Sollte  das  Wort  in mehrere Lücken passen, so wird es zunächst übersprungen. Sobald einmal alle Wörter durchgegangen wurden wird noch einmal geprüft ob eines der Wörter in eine oder mehr Lücken passt. Sollte irgendein Wort  noch  eine  Lücke  finden,  der  es  eindeutig  zuzuordnen  ist,  so  wird  die  Schleife noch  nicht abgebrochen und startet  erneut. Dieses  ganz  Verfahren  läuft  also so  lange,  bis sich  kein Wort  mehr einer Lücke mithilfe eines Buchstaben zuordnen lässt. Sobald die Schleife beendet wurde kann es keine Lücke mehr geben, die einen gegebenen Buchstaben hat. Das einzige Mittel, um die Wörter zuzuordnen, ist nun also noch die Länge. Also iteriert das Programm wieder über alle Wörter und sucht für jedes Wort  eine  noch  nicht  gefüllte  Lücke,  die  genauso  lang  ist  wie  das  Wort.  Wenn  die  Lücke  gefunden wurde, wird das Wort hier eingefügt und aus dem \emph{words} Array gelöscht. Nach diesem Loop kann es nun keine ungefüllte Lücke mehr geben.

Um zu prüfen, ob ein Wort anhand des gegebenen Buchstaben und der Länge in eine Lücke passt, wird die Methode \emph{fits()} benutzt. Diese bekommt zwei Übergabeparameter. Einmal das Wort, welches in die Lücke eingefügt werden soll, und die Lücke, in die das Wort eingefügt werden soll. Diese Methode läuft zunächst  einmal  über  die  Lücke  und sucht nach  einem  gegebenen  Buchstaben,  dessen  Position im String der Lücke dann gespeichert wird. Sollte kein Buchstabe gefunden werden, so gibt die Methode \emph{false} zurück, da das Wort ja nicht eindeutig zuwiesen werden kann. Sollte ein Buchstaben gefunden worden  sein,  prüfen  wir  noch  im  einzufügenden  Wort,  ob  es  an  der  gleichen  Position  den  gleichen Buchstaben  hat  und  ob  die  Länge  der  beiden  Strings  übereinstimmen.  Da  jeder  Lücke  eindeutig ein Wort zuzuordnen sein muss, muss das Wort also in diese Lücke eingefügt werden, die Methode gibt \emph{true} zurück.

\subsection{Dokumentation der Beispiele}

\subsubsection{Selbsterstelltes Beispiel}
Die Funktion des Programms soll nochmal an folgendem Beispiel erläutert werden:
\begin{itemize}
    \item {\_}a{\_} {\_}{\_}s{\_} w{\_}{\_} {\_}{\_}{\_} {\_}{\_}d{\_}{\_}{\_} K{\_}{\_}{\_} !
    \item Pudels also war des Das Kern
\end{itemize}

Das Programm liest nun den Lückentext in den \emph{sentence} Array ein. Dieser hätte nun an der Stelle 2 zum Beispiel {\glqq}\_\_s\_{\grqq} und an der Stelle 3 {\glqq}w\_\_{\grqq}. Die einzufügenden Wörter werden im \emph{words} Array gespeichert. An der Stelle 2 zum Beispiel {\glqq}war{\grqq} und an der Stelle 3 {\glqq}des{\grqq}. Der \emph{sentence} Array hat nun eine Länge von 7 und \emph{words} 6. Nun läuft das Programm in der Schleife einmal über alle Wörter und zählt, wie vielen Lücken die Worte zugeordnet werden könnten. Das erste Wort {\glqq}Pudels{\grqq} findet für sich nur genau eine Lücke. Da es also eindeutig zuzuordnen ist wird es in Lücke 5 eingefügt und  aus  \emph{words} entfernt. Das  Wort {\glqq}also{\grqq} ist  eindeutig  der  zweiten  Lücke zuzuordnen. Das Wort {\glqq}war{\grqq} hat nun zwei Lücken, in die es anhand der gegebenen Buchstaben passen würde (Lücke 1 und 3). Deshalb wird es vorerst übersprungen. Das Wort {\glqq}des{\grqq} lässt sich mithilfe der gegebenen  Buchstaben  keiner  Lücke  eindeutig  zuordnen,  weshalb  es  auch  übersprungen  wird.  Das Wort {\glqq}Das{\grqq} lässt sich nun wieder eindeutig der ersten Lücke zuordnen, wird also auch eingefügt. {\glqq}Kern{\grqq} ist  auch  eindeutig  der  Lücke  6  zuzuordnen,  wird  also  eingefügt.  Nach  diesem  ersten  Durchgang  der Schleife sehen die Arrays also wie folgt aus:

\begin{labeling}{sentence}
    \item [sentence] Das also w{\_}{\_} {\_}{\_}{\_} Pudels Kern !
    \item [words] war des
\end{labeling}

Nun  wird  geprüft  ob  es  noch  Wörter  gibt,  die  sich  durch  gegebene  Buchstaben  noch  einer  Lücke zuordnen lassen. Da {\glqq}war{\grqq} noch eine Lücke findet wird die Schleife wiederholt. {\glqq}war{\grqq} lässt sich nun eindeutig der dritten Lücke zuordnen, da die andere Lücke, für die es auch gepasst hätte, ja nun bereits gefüllt  ist. Deshalb kann es nun in den Satz eingefügt werden. Das letzte Wort {\glqq}das{\grqq} ist nun keiner Lücke mehr zuzuordnen, weshalb die Schleife nun abbricht. Jetzt sehen die beiden Arrays so aus:

\begin{labeling}{sentence}
    \item [sentence] Das also war {\_}{\_}{\_} Pudels Kern !
    \item [words] des
\end{labeling}

Nun folgt noch der Loop, der die Wörter lediglich anhand ihrer Länge den Lücken zuordnet. Das Wort {\glqq}war{\grqq} ist nun das einzige Wort im \emph{words} Array. {\glqq}war{\grqq} hat eine Länge von 3. Nun wird im Satz nach einer noch nicht gefüllten Lücke der Länge 3 gesucht, welche an Stelle 4 gefunden wird. Somit gibt es nun kein Wort mehr im \emph{words} Array und \emph{sentence} sieht wie folgt aus:\\
Das also war des Pudels Kern !\\
Der Satz ist also fertig und wird ausgegeben.

\subsubsection{raetsel0}
Der fertige Satz lautet:\\
oh je, was für eine arbeit!

\subsubsection{raetsel1}
Der fertige Satz lautet:\\
Am Anfang wurde das Universum erschaffen. Das machte viele Leute sehr wütend und wurde allenthalben als Schritt in die falsche Richtung angesehen.

\subsubsection{raetsel2}
Der fertige Satz lautet:\\
Als Gregor Samsa eines Morgens aus unruhigen Träumen erwachte, fand er sich in seinem Bett zu einem ungeheuren Ungeziefer verwandelt.

\subsubsection{raetsel3}
Der fertige Satz lautet:\\
Informatik ist die Wissenschaft von der systematischen Darstellung, Speicherung, Verarbeitung und Übertragung von Informationen, besonders der automatischen Verarbeitung mit Digitalrechnern.

\subsubsection{raetsel4}
Der fertige Satz lautet:\\
Opa Jürgen blättert in einer Zeitschrift aus der Apotheke und findet ein Rätsel. Es ist eine Liste von Wörtern gegeben, die in die richtige Reihenfolge gebracht werden sollen, so dass sie eine lustige Geschichte ergeben. Leerzeichen und Satzzeichen sowie einige Buchstaben sind schon vorgegeben.

\subsection{Quellcode}

\begin{figure}[H]
\centering
\begin{lstlisting}  
boolean[] filled = new boolean[sentence.size()];
for(int i = 0; i < filled.length; i++){
    if(isPunctuation(sentence.get(i))) filled[i] = true;
    else filled[i] = false;
}
\end{lstlisting}
\caption{Vordefinierter Array, der angibt welche Lücke gefüllt ist}
\end{figure}

\begin{figure}[H]
\centering
\begin{lstlisting}
boolean finished = true;
do {
    finished = true;
    for(int i = 0; i < sentence.size(); i++) {
        if(!filled[i]) {
            int posWords = 0;
            ArrayList<Integer> positions = new ArrayList<>();
            for(int j = 0; j < words.size(); j++) {
                if(fits(words.get(j), sentence.get(i))) {
                    boolean availableTwice = false;
                    for(Integer o : positions) {
                        if(words.get(o).equals(words.get(j))) {
                            availableTwice = true;
                            break;
                        }
                    }
                    if(!availableTwice) {
                        posWords++;
                        positions.add(j);
                    }
                }
            }
            if(posWords == 1) {
                for(int j = 0; j < words.size(); j++) {
                    if(fits(words.get(j), sentence.get(i))) {
                        sentence.set(i, words.get(j));
                        words.remove(j);
                        filled[i] = true;
                        posWords--;
                        break;
                    }
                }
            }
        }
    }
    for(int i = 0; i < sentence.size(); i++) {
        int posWords = 0;
        if(!filled[i]) {
            for(int j = 0; j < words.size(); j++) {
                if(fits(words.get(j), sentence.get(i))) {
                    finished = false;
                    break;
                }
            }
        }
    }
}while(!finished);
\end{lstlisting}
\caption{Generelle Schleife, die die Lücken füllt}
\end{figure}

\begin{figure}[H]
\centering
\begin{lstlisting}
for(int i = 0; i < sentence.size(); i++) {
    if(!filled[i]) {
        for(int j = 0; j < words.size(); j++) {
            if(sentence.get(i).length() == words.get(j).length()) {
                sentence.set(i, words.get(j));
                words.remove(j);
                j--;
                filled[i] = true;
            }
        }
    }
}
\end{lstlisting}
\caption{Zuordnung der restlichen Wörter anhand ihrer Länge}
\end{figure}

\begin{figure}[H]
    \centering
\begin{lstlisting}
public static boolean fits(String word, String gap) {
    if(!isPunctuation(gap)) {
        char given = ' ';
        int givenPos = -1;
        
        for(int i = 0; i < gap.length(); i++) {
            if(gap.charAt(i) != '_') {
                given = gap.charAt(i);
                givenPos = i;
                break;
            }
        }
        if(givenPos == -1) return false;
        if( gap.length() == word.length() && gap.charAt(givenPos) == word.charAt(givenPos) ) {
            return true;
        }
        else return false;
        
    }
    return false;
}
\end{lstlisting}
    \caption{Die Methode \emph{fits()} prüft, ob ein Wort in eine Lücke passt}
\end{figure}

\begin{figure}[H]
    \centering
\begin{lstlisting}
    public static boolean isPunctuation(String string) {
    	if(string.contains("!") || string.contains(",") || string.contains("?") || string.contains(".")) return true;
    	else return false;
    }
\end{lstlisting}
\caption{Die Methode \emph{isPunctuation} gibt zurück, ob ein Element aus dem \emph{sentence} Array ein Satzzeichen ist.}
\end{figure}

\section{Dreieckspuzzle}
\subsection{Lösungsidee}

Ein Algorithmus soll durch systematisches Probieren alle sinnvollen Möglichkeiten testen. Das Programm legt erst das erste Puzzleteil, versucht dann dessen anliegende Kanten mit Teilen zu füllen. Sollte es für ein Puzzleteil keine verfügbaren Teile mehr geben, die an die Kante passen, geht der Algorithmus mittels Backtracking zurück. Sobald er wieder zu einem Teil kommt, bei dem er andere Teile noch nicht probiert hat, versucht er das Puzzle ab hier wieder neu aufzubauen.

\subsection{Umsetzung}

Zur Darstellung der Struktur des Puzzle wird ein ungerichteter und ungewichteter Graph verwendet. Der Aufbau wird in Abbildung \ref{Graph1} gezeigt.

\begin{figure}[h]
    \centering
    \begin{tikzpicture}
        \begin{scope}[every node/.style={circle,thick,draw}]
            \node (0) at (0,0) {0};
            \node (1) at (-1.5,-1.5) {1};
            \node (2) at (0,-1.5) {2};
            \node (3) at (1.5,-1.5) {3};
            \node (4) at (-3,-3) {4};
            \node (5) at (-1.5,-3) {5};
            \node (6) at (0,-3) {6};
            \node (7) at (1.5,-3) {7};
            \node (8) at (3,-3) {8};
        \end{scope}
        
        \begin{scope}
            %\path[-] (0) edge node[sloped,above]{Text} (2);
            \path[-] (0) edge (2);
            \path[-] (2) edge (1);
            \path[-] (2) edge (3);
            \path[-] (1) edge (5);
            \path[-] (4) edge (5);
            \path[-] (5) edge (6);
            \path[-] (6) edge (7);
            \path[-] (7) edge (3);
            \path[-] (7) edge (8);
        \end{scope}
    \end{tikzpicture}
    \caption{Interne Speicherung der Puzzlestruktur}
    \label{Graph1}
\end{figure}

Die Knoten bilden die einzelnen Puzzleteile. Wenn eine Kante im Graph existiert, dann berühren sich die beiden Puzzleteile auch im Puzzle, es muss also an den Stellen geprüft werden, ob sie zusammenpassen. Das ist der Fall, wenn beispielsweise die rechte Kante des einen Teils addiert mit der linken Kante des anderen Teils 0 ergibt.

Im Folgenden wird erst auf die einzelnen Klassen und deren Funktion eingegangen, anschließend wird die Vorgehensweise des Algorithmus anhand von Zeichnungen erläutert.

\subsubsection{Klassen}
\begin{figure}[h]
    \centering
    \begin{tikzpicture} 
        \umlclass{Tile}{
            $+$ values: int[]\\
            $+$ flipped: boolean
        }{
            $+$ rotate(): void\\
            $+$ flip(): void
        }
    \end{tikzpicture}
    \caption{Die Klasse \emph{Tile}}
    \label{tile}
\end{figure}

Die Klasse \emph{Tile} (Abbildung \ref{tile}) repräsentiert ein Puzzleteil. Dazu müssen die drei Kantenwerte gespeichert werden. Dies geschieht durch den Array \emph{values}. Die Seiten haben die Indizes wie folgt: $0$: links, $1$ mitte, $2$ rechts. Zudem muss gespeichert werden, ob ein Tile geflippt ist oder nicht. Dies ist nur bei den Stellen $2$, $5$, $7$ im Graph der Fall. Wenn ein Tile geflippt wird, müssen die Werte der linken und rechten Seite getauscht werden. Die \emph{rotate()} Methode rotiert das Tile einmal um $120^\circ$.

\begin{figure}[h]
    \centering
    \begin{tikzpicture} 
        \umlclass{Graph}{
            $-$ matrix: int[][]\\
            $+$ tiles: Tile[]\\
            $+$ puzzle: int[]\\
            $-$ placedTiles: int[][]
        }{
            $+$ Graph(tiles: Tile[])\\
            $+$ fillWithTiles(): boolean\\
            $-$ fillLink(indexMatrix: int, links: ArrayList$<$Integer$>$, index: int): boolean\\
            $-$ fillBorders(tile: int): boolean\\
            $-$ fit(indexTiles: int, indexMatrix: int): boolean\\
            $-$ removeAllPlaced(indexMatrix: int): void\\
            $-$ removePlaced(indexMatrix: int, value: int): void\\
            \dots
        }
    \end{tikzpicture}
    \caption{Die Klasse \emph{Graph}}
\end{figure}

Der Graph speichert seine Adjazenzmatrix, die als Wert $-1$, $0$ und $1$ annehmen kann. $-1$ bedeutet, dass diese Kante nicht existiert. Das ist der Fall, wenn sich die zwei Teile im echten Puzzle nicht berühren können, z.B. die rechte Kante der $0$ und die untere Kante der $4$. Den Wert $0$ nimmt eine Kante an, wenn diese aktuell nicht auf beiden Seiten besetzt ist, z.B. wenn in Abbildung \ref{Graph1} Teil 5 fehlen würde, hätten die Kanten 4-5, 1-5 und 5-6 den Wert $0$. Der Wert $1$ bedeutet, dass die Kante besetzt ist. Ist das Puzzle gelöst, haben also alle Kanten den Wert $-1$ oder $1$. $0$ würde bedeuten, dass es noch eine Kante gibt, die besetzt werden muss. Der Graph speichert im \emph{Tile} Array alle Puzzleteile, die es gibt. Der puzzle-Array speichert die Position jedes Teils im Graphen. Ist das Teil nicht im Graphen, hat puzzle an der Stelle des Teils den Wert $-1$. Der Array \emph{placedTiles} wird verwendet, um beim Backtracking alle platzierten Teile entfernen zu können. Dieser speichert welche Teile von wem gelegt wurden. Jeder Index im Array speichert einen Array, der angibt, welche Positionen im Puzzle von diesem Index gelegt wurden. Die Methoden \emph{removeAllPlaced} und \emph{removePlaced} werden verwendet, um falsch gelegte Teile wieder zu entfernen. Sie kümmern sich gleichzeitig darum, dass alle rekursiv gelegten Teile ebenfalls entfernt werden.

Es wurden bewusst nicht alle Methoden in das Klassendiagramm übernommen, die wichtigen Methoden sind allerdings vorhanden. Die restlichen Methoden sind zur Erklärung des Algorithmus nicht von Bedeutung, sie fügen beispielsweise eine Kante am Anfang ein oder setzen das Puzzle zurück. Sie lassen sich dennoch im Anhang finden.

\subsubsection{Algorithmus}

Die Methode \emph{fillWithTiles()} wird aufgerufen, um das Puzzle zu lösen. Diese geht über jedes Puzzleteil und versucht das Puzzle damit an Stelle $0$ im Graphen zu lösen. Dazu wird \emph{fillBorders(0)} aufgerufen. Für den Quellcode der Methode, siehe Abbildung \ref{fillWithTiles}.

Die Methode \emph{fillBorders()} iteriert einmal über alle Kanten und speichert unbesetzte Kanten in einer ArrayList. Im Anschluss wird \emph{fillLink()} mit der eigenen Position im Puzzle und der ArrayList der Kanten aufgerufen. 

\emph{fillLink()} sucht nun rekursiv für alle übergebenen Kanten Puzzleteile. Es beginnt mit der ersten Kante in der \emph{links} ArrayList. Zuerst wird ein \emph{boolean} Array angelegt, an dem später überprüft werden kann, ob ein bestimmtes Teil schon probiert wurde. Beim Erstellen werden direkt alle Puzzleteile als besucht markiert, die schon im Puzzle verwendet werden, damit diese nicht erneut gelegt werden. Jetzt werden alle nicht besuchten Teile probiert. Dazu wird mit der Methode \emph{fit()} überprüft, ob das potentielle Teil an die Position passt. Im nächsten Absatz wird \emph{fit()} genauer erläutert. Wurde ein passendes Teil gefunden, wird es vorerst eingefügt und \emph{fillBorders()} bei diesem aufgerufen. Klappt es, ist dieser "Teilbaum" komplett und \emph{fillLink()} ruft sich selbst erneut auf, allerdings mit einem größeren Index, sodass dieser Aufruf versucht, die nächste Kante zu füllen. Sobald es keine Kanten mehr zu füllen gibt, wird \emph{true} zurückgegeben. Klappt \emph{fillBorders()} oder der nächste \emph{fillLink()} Aufruf jedoch nicht, da diese \emph{false} zurückgeben, werden erst die falsch platzierten Teile entfernt und das Teil entweder rotiert und alles wird erneut probiert, oder nach drei Rotationen wird das nächste Tile probiert.

\emph{fit()} prüft zuerst, ob die aktuelle Position $2$, $5$ oder $7$ ist, denn dann muss das Teil geflippt sein. Danach wird allgemein angenommen, dass das Teil passt. Es wird über alle Kanten des Teils iteriert. Wenn eine gefunden wurde, bei der der Partner vorhanden ist, das Teil also eventuell nicht passen kann, wird getestet, ob das Teil passt. Hierfür muss erstmal bestimmt werden, welche beiden Seiten miteinander verglichen werden müssen. Wie man in Abbildung \ref{Graph1} erkennen kann, ist die Differenz zweier Teile auf einer Höhe $=\pm 1$. Sind sie auf verschiedenen Höhen, ist die Differenz $\neq\pm 1$. In diesem Fall werden die beiden mittleren Seiten miteinander verglichen. Sonst muss noch bestimmt werden, ob das gefundene Teil links oder rechts vom Teil, das die Methode aufruft, ist. Der Index vom gefundenen Teil wird von dem des aufrufenden Teils abgezogen. Ist die Differenz $-1$, muss die rechte Seite des aufrufenden mit der linken des gefundenen Teils verglichen werden und andersrum. Nun werden die Werte der beiden Seiten addiert. Sollte die Summe nicht $0$ sein, passt das Teil nicht und die Methode gibt \emph{false} zurück. Wurden alle Kanten verglichen und das Teil passt überall, wird es eingefügt und \emph{true} zurückgegeben.

\subsection{Dokumentation der Beispiele}

\subsubsection{puzzle0}
In der folgenden Abbildung sieht man die Lösung für "puzzle0.txt" und daneben den Graphen. Die Pfeile zwischen den Knoten stellen nicht die Kanten dar, sondern zeigen, welcher Knoten welchen Knoten gelegt hat und sind nochmals zur Veranschaulichung der Tiefensuche da.

\begin{figure}[H]
    \centering
    \begin{subfigure}[t]{0.45\textwidth}
        \centering
    \begin{tikzpicture}[scale=1]
    %0
    \draw (-1,0) -- node[sloped,above]{$-2$} (1,0); %mitte
    \draw (-1,0) -- node[sloped,above,rotate=180]{$-1$} (0,1.73); %links
    \draw (1,0) -- node[sloped,above,rotate=180]{$1$} (0,1.73); %rechts

    %1
    \draw (-2,-1.73) -- node[sloped,above]{$3$} (0,-1.73);
    \draw (-2,-1.73) -- node[sloped,above,rotate=180]{$-1$} (-1,0);
    \draw (0,-1.73) -- node[sloped,above,rotate=180]{$1$} (-1,0);

    %2
    \draw (-1,0) -- node[sloped,above,rotate=180]{$2$} (1,0);
    \draw (-1,0) -- node[sloped,above,rotate=0]{$-1$} (0,-1.73);
    \draw (1,0) -- node[sloped,above,rotate=0]{$-2$} (0,-1.73);

    %3
    \draw (0,-1.73) -- node[sloped,above]{$-1$} (2,-1.73);
    \draw (0,-1.73) -- node[sloped,above,rotate=180]{$2$} (1,0);
    \draw (2,-1.73) -- node[sloped,above,rotate=180]{$-1$} (1,0);

    %4
    \draw (-3,-3.46) -- node[sloped,above]{$-1$} (-1,-3.46);
    \draw (-3,-3.46) -- node[sloped,above,rotate=180]{$2$} (-2,-1.73);
    \draw (-2,-1.73) -- node[sloped,above,rotate=180]{$-3$} (-1,-3.46);

    %5
    \draw (-2,-1.73) -- node[sloped,above,rotate=180]{$-3$} (0,-1.73);
    \draw (-2,-1.73) -- node[sloped,above,rotate=0]{$3$} (-1,-3.46);
    \draw (0,-1.73) -- node[sloped,above,rotate=0]{$2$} (-1,-3.46);

    %6
    \draw (-1,-3.46) -- node[sloped,above]{$-1$} (1,-3.46);
    \draw (-1,-3.46) -- node[sloped,above,rotate=180]{$-2$} (0,-1.73);
    \draw (1,-3.46) -- node[sloped,above,rotate=180]{$3$} (0,-1.73);

    %7
    \draw (0,-1.73) -- node[sloped,above,rotate=180]{$1$} (2,-1.73);
    \draw (0,-1.73) -- node[sloped,above,rotate=0]{$-3$} (1,-3.46);
    \draw (2,-1.73) -- node[sloped,above,rotate=0]{$-2$} (1,-3.46);

    %8
    \draw (1,-3.46) -- node[sloped,above]{$2$} (3,-3.46);
    \draw (1,-3.46) -- node[sloped,above,rotate=180]{$2$} (2,-1.73);
    \draw (3,-3.46) -- node[sloped,above,rotate=180]{$-1$} (2,-1.73);

    \end{tikzpicture}
    \end{subfigure}
\hfill
    \begin{subfigure}[t]{0.45\textwidth}
    \centering

    \begin{tikzpicture}
        \begin{scope}[every node/.style={circle,thick,draw}]
            \node (0) at (0,0) {0};
            \node (1) at (-1.5,-1.5) {1};
            \node (2) at (0,-1.5) {2};
            \node (3) at (1.5,-1.5) {3};
            \node (4) at (-3,-3) {4};
            \node (5) at (-1.5,-3) {5};
            \node (6) at (0,-3) {6};
            \node (7) at (1.5,-3) {7};
            \node (8) at (3,-3) {8};
        \end{scope}
        
        \begin{scope}
            %\path[-] (0) edge node[sloped,above]{Text} (2);
            \path[->] (0) edge (2);
            \path[->] (2) edge (1);
            \path[->] (1) edge (5);
            \path[->] (5) edge (4);
            \path[->] (5) edge (6);
            \path[->] (6) edge (7);
            \path[->] (7) edge (3);
            \path[->] (7) edge (8);
        \end{scope}
    \end{tikzpicture}
    \end{subfigure}
    \caption{Die Lösung von puzzle0}
\end{figure}

\subsubsection{puzzle1}

Der Algorithmus gibt folgende Lösung aus:
\begin{figure}[H]
    \centering
    \begin{tikzpicture}[scale=1]
    %0
    \draw (-1,0) -- node[sloped,above]{$-1$} (1,0); %mitte
    \draw (-1,0) -- node[sloped,above,rotate=180]{$-1$} (0,1.73); %links
    \draw (1,0) -- node[sloped,above,rotate=180]{$3$} (0,1.73); %rechts

    %1
    \draw (-2,-1.73) -- node[sloped,above]{$-3$} (0,-1.73);
    \draw (-2,-1.73) -- node[sloped,above,rotate=180]{$-2$} (-1,0);
    \draw (0,-1.73) -- node[sloped,above,rotate=180]{$1$} (-1,0);

    %2
    \draw (-1,0) -- node[sloped,above,rotate=180]{$1$} (1,0);
    \draw (-1,0) -- node[sloped,above,rotate=0]{$-1$} (0,-1.73);
    \draw (1,0) -- node[sloped,above,rotate=0]{$-2$} (0,-1.73);

    %3
    \draw (0,-1.73) -- node[sloped,above]{$-3$} (2,-1.73);
    \draw (0,-1.73) -- node[sloped,above,rotate=180]{$2$} (1,0);
    \draw (2,-1.73) -- node[sloped,above,rotate=180]{$-1$} (1,0);

    %4
    \draw (-3,-3.46) -- node[sloped,above]{$-1$} (-1,-3.46);
    \draw (-3,-3.46) -- node[sloped,above,rotate=180]{$3$} (-2,-1.73);
    \draw (-2,-1.73) -- node[sloped,above,rotate=180]{$-3$} (-1,-3.46);

    %5
    \draw (-2,-1.73) -- node[sloped,above,rotate=180]{$3$} (0,-1.73);
    \draw (-2,-1.73) -- node[sloped,above,rotate=0]{$3$} (-1,-3.46);
    \draw (0,-1.73) -- node[sloped,above,rotate=0]{$-1$} (-1,-3.46);

    %6
    \draw (-1,-3.46) -- node[sloped,above]{$-1$} (1,-3.46);
    \draw (-1,-3.46) -- node[sloped,above,rotate=180]{$1$} (0,-1.73);
    \draw (1,-3.46) -- node[sloped,above,rotate=180]{$2$} (0,-1.73);

    %7
    \draw (0,-1.73) -- node[sloped,above,rotate=180]{$3$} (2,-1.73);
    \draw (0,-1.73) -- node[sloped,above,rotate=0]{$-2$} (1,-3.46);
    \draw (2,-1.73) -- node[sloped,above,rotate=0]{$2$} (1,-3.46);

    %8
    \draw (1,-3.46) -- node[sloped,above]{$3$} (3,-3.46);
    \draw (1,-3.46) -- node[sloped,above,rotate=180]{$-2$} (2,-1.73);
    \draw (3,-3.46) -- node[sloped,above,rotate=180]{$-1$} (2,-1.73);
    \end{tikzpicture}
    \caption{Die Lösung von puzzle1}
\end{figure}

\subsubsection{puzzle2}

Der Algorithmus gibt folgende Lösung aus:

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[scale=1]
    %0
    \draw (-1,0) -- node[sloped,above]{$-1$} (1,0); %mitte
    \draw (-1,0) -- node[sloped,above,rotate=180]{$-2$} (0,1.73); %links
    \draw (1,0) -- node[sloped,above,rotate=180]{$-3$} (0,1.73); %rechts

    %1
    \draw (-2,-1.73) -- node[sloped,above]{$-3$} (0,-1.73);
    \draw (-2,-1.73) -- node[sloped,above,rotate=180]{$-4$} (-1,0);
    \draw (0,-1.73) -- node[sloped,above,rotate=180]{$-2$} (-1,0);

    %2
    \draw (-1,0) -- node[sloped,above,rotate=180]{$1$} (1,0);
    \draw (-1,0) -- node[sloped,above,rotate=0]{$2$} (0,-1.73);
    \draw (1,0) -- node[sloped,above,rotate=0]{$-4$} (0,-1.73);

    %3
    \draw (0,-1.73) -- node[sloped,above]{$-2$} (2,-1.73);
    \draw (0,-1.73) -- node[sloped,above,rotate=180]{$4$} (1,0);
    \draw (2,-1.73) -- node[sloped,above,rotate=180]{$-3$} (1,0);

    %4
    \draw (-3,-3.46) -- node[sloped,above]{$-2$} (-1,-3.46);
    \draw (-3,-3.46) -- node[sloped,above,rotate=180]{$1$} (-2,-1.73);
    \draw (-2,-1.73) -- node[sloped,above,rotate=180]{$-4$} (-1,-3.46);

    %5
    \draw (-2,-1.73) -- node[sloped,above,rotate=180]{$3$} (0,-1.73);
    \draw (-2,-1.73) -- node[sloped,above,rotate=0]{$4$} (-1,-3.46);
    \draw (0,-1.73) -- node[sloped,above,rotate=0]{$-1$} (-1,-3.46);

    %6
    \draw (-1,-3.46) -- node[sloped,above]{$-2$} (1,-3.46);
    \draw (-1,-3.46) -- node[sloped,above,rotate=180]{$1$} (0,-1.73);
    \draw (1,-3.46) -- node[sloped,above,rotate=180]{$-3$} (0,-1.73);

    %7
    \draw (0,-1.73) -- node[sloped,above,rotate=180]{$2$} (2,-1.73);
    \draw (0,-1.73) -- node[sloped,above,rotate=0]{$3$} (1,-3.46);
    \draw (2,-1.73) -- node[sloped,above,rotate=0]{$1$} (1,-3.46);

    %8
    \draw (1,-3.46) -- node[sloped,above]{$1$} (3,-3.46);
    \draw (1,-3.46) -- node[sloped,above,rotate=180]{$-1$} (2,-1.73);
    \draw (3,-3.46) -- node[sloped,above,rotate=180]{$-3$} (2,-1.73);
    \end{tikzpicture}
    \caption{Die Lösung von puzzle2}
\end{figure}

\subsubsection{puzzle3}

Der Algorithmus gibt folgende Lösung aus:
\begin{figure}[H]
    \centering
    \begin{tikzpicture}[scale=1]
    %0
    \draw (-1,0) -- node[sloped,above]{$4$} (1,0); %mitte
    \draw (-1,0) -- node[sloped,above,rotate=180]{$10$} (0,1.73); %links
    \draw (1,0) -- node[sloped,above,rotate=180]{$10$} (0,1.73); %rechts

    %1
    \draw (-2,-1.73) -- node[sloped,above]{$7$} (0,-1.73);
    \draw (-2,-1.73) -- node[sloped,above,rotate=180]{$10$} (-1,0);
    \draw (0,-1.73) -- node[sloped,above,rotate=180]{$-2$} (-1,0);

    %2
    \draw (-1,0) -- node[sloped,above,rotate=180]{$-4$} (1,0);
    \draw (-1,0) -- node[sloped,above,rotate=0]{$2$} (0,-1.73);
    \draw (1,0) -- node[sloped,above,rotate=0]{$3$} (0,-1.73);

    %3
    \draw (0,-1.73) -- node[sloped,above]{$2$} (2,-1.73);
    \draw (0,-1.73) -- node[sloped,above,rotate=180]{$-3$} (1,0);
    \draw (2,-1.73) -- node[sloped,above,rotate=180]{$10$} (1,0);

    %4
    \draw (-3,-3.46) -- node[sloped,above]{$10$} (-1,-3.46);
    \draw (-3,-3.46) -- node[sloped,above,rotate=180]{$10$} (-2,-1.73);
    \draw (-2,-1.73) -- node[sloped,above,rotate=180]{$-9$} (-1,-3.46);

    %5
    \draw (-2,-1.73) -- node[sloped,above,rotate=180]{$-7$} (0,-1.73);
    \draw (-2,-1.73) -- node[sloped,above,rotate=0]{$9$} (-1,-3.46);
    \draw (0,-1.73) -- node[sloped,above,rotate=0]{$8$} (-1,-3.46);

    %6
    \draw (-1,-3.46) -- node[sloped,above]{$10$} (1,-3.46);
    \draw (-1,-3.46) -- node[sloped,above,rotate=180]{$-8$} (0,-1.73);
    \draw (1,-3.46) -- node[sloped,above,rotate=180]{$-6$} (0,-1.73);

    %7
    \draw (0,-1.73) -- node[sloped,above,rotate=180]{$-2$} (2,-1.73);
    \draw (0,-1.73) -- node[sloped,above,rotate=0]{$6$} (1,-3.46);
    \draw (2,-1.73) -- node[sloped,above,rotate=0]{$5$} (1,-3.46);

    %8
    \draw (1,-3.46) -- node[sloped,above]{$10$} (3,-3.46);
    \draw (1,-3.46) -- node[sloped,above,rotate=180]{$-5$} (2,-1.73);
    \draw (3,-3.46) -- node[sloped,above,rotate=180]{$10$} (2,-1.73);
    \end{tikzpicture}
    \caption{Die Lösung von puzzle3}
\end{figure}

\subsection{Quellcode}

\begin{figure}[H]
    \centering
\begin{lstlisting}
public boolean fillWithTiles() {
	for(int i = 0; i < this.tiles.length; i++) {
		// puzzle-Array wird zurueckgesetzt
		resetPuzzle();

        // Das Tile wird an die Stelle 0 im Graph gesetzt
        puzzle[i] = 0;
		
        if(fillBorders(0)) {
            // Puzzle wurde gelöst
            return true;
        }

        resetPuzzle();
        puzzle[i] = 0;
        tiles[i].rotate();

        // [...] fillBorders(0) wird für jede Rotation des Tile wiederholt
    }
	return false;
}
\end{lstlisting}
    \caption{Die Methode \emph{fillWithTiles()}}
\end{figure}

\begin{figure}[H]
    \centering
    \begin{lstlisting}
private boolean fillLink(int indexMatrix, ArrayList<Integer> links, int index) {
    if(index >= links.size()) {
        return true;
    }
    if(getIndexTiles(links.get(index)) != -1) {
        return fillLink(indexMatrix, links, index+1);
    }
    
    boolean[] visited = new boolean[9];
    for (int i = 0; i < tiles.length; i++) {
        if(puzzle[i] != -1) {
            visited[i] = true;
        }
    }
        
    boolean tileFound = false;
    for(int k = 0; k < visited.length; k++) {
        if(!visited[k]) {
            visited[k] = true;
            
            for(int i = 0; i < 3; i++) {
                if(fit(k, links.get(index))) {
                    tileFound = true;
                    addPlacedTile(indexMatrix, links.get(index));
                    if(fillBorders(links.get(index))) {
                        
                        if(fillLink(indexMatrix, links, index+1)) {
                            return true;
                        }
                        else {
                            removePlaced(indexMatrix, links.get(index));
                        }
                    }
                    else {
                        removePlaced(indexMatrix, links.get(index));
                        tileFound = false;
                    }
                }
                tiles[k].rotate();
            }
        }
    }
    if(!tileFound) {
        removePlaced(indexMatrix, links.get(index));
        return false;
    }
    return false;
}
    \end{lstlisting}
    \caption{Die Methode \emph{fillLink()}}
\end{figure}

\begin{figure}[H]
    \centering
    \begin{lstlisting}
private boolean fillBorders(int indexMatrix) {
    ArrayList<Integer> links = new ArrayList<>();
    for(int j = 0; j < matrix.length; j++) {
        if(matrix[indexMatrix][j] == 0) {
            links.add(j);
        }
    }
    if(fillLink(indexMatrix, links, 0)) {
        return true;
    }
    else {
        removeAllPlaced(indexMatrix);
        return false;
    }
}
    \end{lstlisting}
    \caption{Die Methode \emph{fillBorders()}}
\end{figure}

\begin{figure}[H]
    \centering
    \begin{lstlisting}
private boolean fit(int indexTiles, int indexMatrix) {
    if(indexMatrix == 2 || indexMatrix == 5 || indexMatrix == 7) {
        if(!tiles[indexTiles].flipped) {
            tiles[indexTiles].flip();
        }
    }
    else {
        if(tiles[indexTiles].flipped) {
            tiles[indexTiles].flip();
        }
    }
    boolean fits = true;
    for(int i = 0; i < matrix.length; i++) {
        if(matrix[indexMatrix][i] != -1 && getIndexTiles(i) != -1) {
            int side = indexMatrix - i;
            int side1 = 0;
            int side2 = 0;
            int tile2 = getIndexTiles(i);
            
            if(side == -1) {
                side1 = 2;
                side2 = 0;
            }
            else if(side == 1) {
                side1 = 0;
                side2 = 2;
            }
            else {
                side1 = 1;
                side2 = 1;
            }
            if(tiles[indexTiles].values[side1] + tiles[tile2].values[side2] != 0) {
                fits = false;
                break;
            }
        }
    }
    if(fits) {
        for(int i = 0; i < matrix.length; i++) {
            if(matrix[indexMatrix][i] == 0 && getIndexTiles(i) != -1) {
                updateTrueLink(indexMatrix, i);
            }
        }
        puzzle[indexTiles] = indexMatrix;
        return true;
    }
    else {
        return false;
    }
}
    \end{lstlisting}
    \caption{Die Methode \emph{fit()}}
\end{figure}

\section{Tobis Turnier}
\subsection{Lösungsidee}

Um die verschiedenen Turniere zu Simulieren wurde  für jede Turnierform eine Methode erstellt, die den Sieger des Turniers zurückgibt. So können können viele Turniere einfach durch Aufrufe dieser Methoden simuliert werden.

\subsection{Umsetzung}

Wie bereits erwähnt wurde für jede Turnierform eine Methode erstellt. Im folgenden Teil werden die einzelnen Methoden genauer erläutert:

\subsubsection{Klassendiagramme}
\begin{figure}[H]
    \centering
    \begin{tikzpicture} 
        \umlclass{Player}{
            $+$ id: int\\
            $+$ strength: int\\
            $+$ wins: int
        }{
            $+$ Player(id: int, strength: int)
        }
    \end{tikzpicture}
    \caption{Die Klasse \emph{Player}}
    \end{figure}

    \begin{figure}[H]
    \centering
    \begin{tikzpicture} 
        \umlclass{Node}{
            $+$ left: Node\\
            $+$ right: Node\\
            $+$ player: Player
        }{
            $+$ Node()\\
            $+$ Node(player: Player)\\
            $+$ getWinner(): Player\\
            $+$ getx5Winner(): Player\\
            $+$ create(players: ArrayList$<$Player$>$): void\\
            $+$ \underline{match(p1: Player, p2: Player): Player}\\
            $+$ \underline{matchx5(p1: Player, p2: Player): Player}
        }
    \end{tikzpicture}
    \caption{Die Klasse \emph{Node}}
\end{figure}

    \begin{figure}[H]
    \centering
    \begin{tikzpicture} 
        \umlclass{Turnier}{
            $+$ \underline{players: ArrayList$<$Player$>$}
        }{
            $+$ \underline{main(args: String[]): void}\\
            $+$ \underline{match(p1: Player, p2: Player): Player}\\
            $+$ \underline{league(players: ArrayList$<$Player$>$): Player}\\
            $+$ \underline{ko(players: ArrayList$<$Player$>$): Player}\\
            $+$ \underline{kox5(players: ArrayList$<$Player$>$): Player}\\
            $+$ \underline{getBest(players: ArrayList$<$Player$>$): int}\\
            $+$ \underline{sortById(players: ArrayList$<$Player$>$): void}
        }
    \end{tikzpicture}
    \caption{Die Klasse \emph{Turnier}}
\end{figure}
\subsubsection{Einlesen der Datei}

Jeder Spieler wird in Form einer eigenen Klasse, die die Spielstärke und die ID speichert, in einem Array gespeichert. Das Programm geht die gegebene Datei lediglich Zeile für Zeile durch und erstellt in jeder Zeile, außer der ersten, einen neuen Spieler, der die Spielstärke hat die die Zeile angibt. Nebenbei zählen wir noch eine Variable hoch, die jedem Spieler eine neue ID zuordnet.

\subsubsection{Die \emph{match}-Methode}

Die \emph{match} Methode realisiert das Spiel RNG im Programm. Sie bekommt zwei Spieler übergeben, von denen nur der
zurückgegeben wird, der das Match gewinnt. Die Methode addiert zuerst die
beiden Spielstärken der Spieler und generiert dann eine zufällige Zahl, die
zwischen dieser Summe und $0$ liegt. Wenn diese generierte Zahl kleiner als die
Stärke von Spieler $1$ ist, so hat dieser gewonnen. Sollte die Zahl größer oder
gleich der Spielstärke von Spieler $2$ sein, so hat dieser gewonnen.

\subsubsection{Liga}

Die Methode \emph{league()} bekommt einen Array aus Spielern übergeben und gibt am Ende einen Spieler zurück, der die Liga gewonnen hat. In der Liga spielt jeder Spieler genau einmal gegen jeden anderen. Um zu wissen, wer bereits gegen wen gespielt hat, speichern wir uns nebenbei einen zweidimensionalen Array aus booleans. Dieser wird dann mithilfe eines Loop an allen Stellen auf false gestellt, außer in der Diagonalen, also zum Beispiel an Stelle [1][1], damit die Spieler nicht einmal gegen sich selbst spielen. Danach startet eine Schleife die so lange läuft, bis der zweidimensionale Array kein false mehr speichert, also jeder Spieler einmal gegen jeden anderen Spieler gespielt hat. In der Schleife wird für jeden Spieler im übergebenen Array einmal über alle Spieler gegangen und anhand des zweidimensionalen Arrays geprüft, ob die beiden Spieler bereits gegeneinander gespielt haben. Sollten sie noch nicht gegeneinander gespielt haben, so spielen sie nun mithilfe der Methode match gegeneinander. Der gewinner des matches fügt dann seiner wins variable einen Sieg hinzu. Außerdem setzen wir den zweidimensionalen Array an der Stelle der beiden Spieler auf true. Sobald diese Schleife nun abbricht hat jeder Spieler nun einmal gegen jeden gespielt und jeder Spieler weiß, wie häufig er gewonnen hat. Nun wird geprüft welcher der Spieler die meisten Siege hat, also die Liga gewonnen hat. Dazu wird erst geprüft, was die höchste Anzahl an Siegen ist, die einer der Spieler erreicht hat. Dann fügen wir in einen neuen Array aus Spielern alle Spieler hinzu, die so viele Siege wie der Spieler mit den meisten Siegen hat. So haben wir nun alle Spieler, die potenziell gewinnen könnten. Sollten mehr als ein Spieler in diesem Array sein, so entscheidet die ID wer gewinnt. Wir zählen eine Variable von 0 hoch und sobald im Array ein Spieler ist, dessen ID gleich der Variable ist geben wir diesen zurück als Gewinner. Wenn wir nur einen Spieler im Array haben, so können wir diesen direkt zurückgeben.

\subsubsection{Ko}

In der \emph{ko} Methode wird zunächst der Turnierbaum erzeugt. Dazu wird eine
Wurzel erstellt, von der aus der Binärbaum nach unten erzeugt wird. Die
Methode bekommt einen Array mit den Spielern übergeben, die in den Turnierbaum
eingefügt werden müssen und gibt den Sieger des Turniers zurück. Die Wurzel
startet die rekursive Methode \emph{create()}, die den Baum erzeugt. Diese Methode
bekommt den Array mit den Spielern übergeben. Die Wurzel fängt nun an. Sollte
der Array nur 2 Spieler speichern, so kann die Wurzel einen der Spieler als
linken Teilbaum speichern und den anderen als rechten. Sollte der Array
länger sein, so erstellt er jeweils rechts und links einen Knoten, der keinen
Spieler speichert, teilt die Spieler gleichmäßig in 2 neue Arrays auf und
führt die Methode \emph{create()} bei diesen, mit den neu erzeugten Arrays erneut aus. So ist
der Array irgendwann nur noch 2 lang und alle Spieler sind in den Blättern des
Baums. Nachdem nun der Baum erzeugt wurde kann das Turnier starten. Hierzu
starten wir bei der Wurzel und gehen den Baum nach unten durch mit der
rekursiven Methode \emph{getWinner()}. Diese prüft ob der aktuelle Knoten bereits einen Spieler besitzt. Sollte er bereits einen Spieler haben, so gibt er diesen zurück. Sollte er keinen haben, so spielen die beiden Spieler der Teilbäume gegeneinander und der Knoten
speichert den Sieger des Matches als seinen Spieler. Sind alle rekursiven Methodenaufrufe abgeschlossen, speichert die Wurzel den Sieger des Turniers.


\subsubsection{Kox5}

Die \emph{kox5()} Methode ist prinzipiell die gleiche wie \emph{ko()}. Das Verfahren ist bis auf
die \emph{match()} Methode genau das gleiche. Hier wurde die Methode \emph{matchx5()} angelegt.
Diese lässt die beiden Spieler fünf mal gegeneinander antreten und es wird gespeichert, wie oft jeder Spieler gewonnen hat. Der Spieler, der häufiger
gewonnen hat, wird dann als Sieger zurückgegeben.

\subsection{Beispiele}
\subsubsection{Selbsterstelltes Beispiel}
Im folgenden Teil wird ein Beispiel durchgespielt, in dem 4 Spieler ein Ko-Turnier veranstalten. Folgende Spieler treten an:

\begin{table}[H]
\centering
\begin{tabular}{@{}cc@{}}
\toprule
Spieler & Spielstärke \\ \midrule
1       & 20          \\
2       & 40          \\
3       & 45          \\
4       & 90          \\ \bottomrule
\end{tabular}
\end{table}

Nachdem diese Spieler nun in einem Array gesammelt wurden, wird die Methode \emph{ko()}
mit diesem Array ausgeführt. Nun wird zunächst eine Wurzel erstellt, die die
Methode \emph{create()} mit dem Array ausführt. Hier wird die Länge
des Arrays geprüft. Da die Länge $4$, und nicht $2$, beträgt, erzeugt die Wurzel
einen neuen linken und einen neuen rechten Teilbaum, die beide keinen Spieler
speichern. Dann wird der Spieler Array aufgeteilt und der linke Knoten bekommt
die ersten der beiden Spieler und der rechte Knoten die hinteren beiden
Spieler. Beide führen wieder jeweils die Methode \emph{create()} aus. Da beide nun
einen Array der Länge $2$ haben, erstellen beide jeweils wieder einen linken und
rechten Knoten, die beide jeweils einen der beiden Spieler aus dem Array
speichern. 

Nun muss noch ein Sieger ermittelt werden. Hierzu wird die Methode
\emph{getWinner()} bei der Wurzel aufgerufen. Da die Wurzel noch keinen Spieler speichert,
gibt sie den Sieger eines Matches zwischen den Spielern des linken und rechten
Teilbaums zurück. Da diese ebenfalls keinen Spieler speichern, geben sie jeweils
den Sieger eines Matches zwischen den Spielern ihrer linken und rechten Knoten bzw. Teilbäume zurück. Diese Abfolge an Spielabläufen ist in den folgenden Abbildungen dargestellt.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \begin{scope}[every node/.style={circle,thick,draw}]
            \node (0) at (0,0) {W};
            \node (1) at (-2,-1.5) {K1};
            \node (2) at (2,-1.5) {K2};
            \node (3) at (-3,-3) {S1};
            \node (4) at (-1,-3) {S2};
            \node (5) at (1,-3) {S3};
            \node (6) at (3,-3) {S4};
        \end{scope}
        
        \begin{scope}
            %\path[-] (0) edge node[sloped,above]{Text} (2);
            \path[-] (0) edge (1);
            \path[-] (0) edge (2);
            \path[-] (1) edge (3);
            \path[-] (1) edge (4);
            \path[-] (2) edge (5);
            \path[-] (2) edge (6);
        \end{scope}
    \end{tikzpicture}
    \caption{Ausgangslage des Turniers}
\end{figure}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \begin{scope}[every node/.style={circle,thick,draw}]
            \node (0) at (0,0) {W};
            \node (1) at (-2,-1.5) {S1};
            \node (2) at (2,-1.5) {S4};
            \node (3) at (-3,-3) {S1};
            \node (4) at (-1,-3) {S2};
            \node (5) at (1,-3) {S3};
            \node (6) at (3,-3) {S4};
        \end{scope}
        
        \begin{scope}
            %\path[-] (0) edge node[sloped,above]{Text} (2);
            \path[-] (0) edge (1);
            \path[-] (0) edge (2);
            \path[<-] (1) edge (3);
            \path[-] (1) edge (4);
            \path[-] (2) edge (5);
            \path[<-] (2) edge (6);
        \end{scope}
    \end{tikzpicture}
    \caption{Schritt 1: S1 gewinnt gegen S2 und S4 gegen S3}
\end{figure}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \begin{scope}[every node/.style={circle,thick,draw}]
            \node (0) at (0,0) {S4};
            \node (1) at (-2,-1.5) {S1};
            \node (2) at (2,-1.5) {S4};
            \node (3) at (-3,-3) {S1};
            \node (4) at (-1,-3) {S2};
            \node (5) at (1,-3) {S3};
            \node (6) at (3,-3) {S4};
        \end{scope}
        
        \begin{scope}
            %[>={Stealth[black]}]
            %\path[-] (0) edge node[sloped,above]{Text} (2);
            \path[-] (0) edge (1);
            \path[<-] (0) edge (2);
            \path[<-] (1) edge (3);
            \path[-] (1) edge (4);
            \path[-] (2) edge (5);
            \path[<-] (2) edge (6);
        \end{scope}
    \end{tikzpicture}
    \caption{Schritt 2: S4 gewinnt gegen S1 und somit das Turnier}
\end{figure}


Im folgenden Teil werden noch die Ergebnisse der einzelnen Dateien dokumentiert. Es wird ermittelt, wie häufig der stärkste Spieler durchschnittlich gewinnt und auf dieser Basis ein Turnierformat empfohlen. Dazu werden alle drei Turnierformate $1000000$ mal durchgeführt und es wird mitgezählt, wie viele Spiele der beste Spieler gewonnen hat, um daraus einen Durchschnittswert zu berechnen.

\subsubsection{spielstaerken1}

Diese Datei beinhaltet $8$ Spieler, deren Spielstärke gleichmäßig verteilt zwischen $0$ und $100$ liegt. Der stärkste Spieler hat eine Stärke von $100$.
Wenn wir die Turnierformen $1000000$ mal simulieren, so ergeben sich für die Siegeswahrscheinlichkeiten des stärksten Spielers folgende Werte:

\begin{table}[H]
    \centering
\begin{tabular}{@{}cc@{}}
\toprule
Turnierform & Siegesrate                \\ \midrule
    Liga        & \SI{34.5}{\percent}       \\
    Ko          & \SI{40.4}{\percent}       \\
    Kox5        & \SI{47.4}{\percent}       \\ \bottomrule
\end{tabular}
\end{table}

Daraus lässt sich schließen, dass die Turnierform Kox5 hier die, mit kleinem Abstand, besten Ergebnisse liefert.

\subsubsection{spielstaerken2}

Diese Datei beinhaltet wieder $8$ Spieler. Die Hälfte der Spieler hat eine relativ niedrige Stärke, während die andere Hälfte relativ Spielstark ist. Der stärkste Spieler hat wieder eine Stärke von $100$.
Wenn wir die Turnierformen $1000000$ mal simulieren, so ergeben sich für die Siegeswahrscheinlichkeiten des stärksten Spielers folgende Werte:

\begin{table}[H]
    \centering
\begin{tabular}{@{}cc@{}}
\toprule
Turnierform & Siegesrate                \\ \midrule
Liga        & \SI{20.9}{\percent}       \\
    Ko          & \SI{30.2}{\percent}       \\
    Kox5        & \SI{32.7}{\percent}       \\ \bottomrule
\end{tabular}
\end{table}

Daraus lässt sich schließen, dass die Turnierform Kox5 hier wieder mit kleinem Abstand die besten Werte liefert.

\subsubsection{spielstaerken3}

Diese Datei beinhaltet $16$ Spieler. Die Spielstärken sind relativ gleichmäßig verteilt und der stärkste Spieler hat eine Stärke von $93$.
Wenn wir die Turnierformen $1000000$ mal simulieren, so ergeben sich für die Siegeswahrscheinlichkeiten des stärksten Spielers folgende Werte:

\begin{table}[H]
    \centering
\begin{tabular}{@{}cc@{}}
\toprule
Turnierform & Siegesrate                \\ \midrule
Liga        & \SI{31.6}{\percent}       \\
    Ko          & \SI{16.6}{\percent}       \\
    Kox5        & \SI{19.2}{\percent}       \\ \bottomrule
\end{tabular}
\end{table}

Hier liefert die Turnierform Liga die mit Abstand besten Werte.

\subsubsection{spielstaerken4}

Diese Datei beinhaltet $16$ Spieler. Alle, bis auf ein Spieler, haben hier die Spielstärke $95$. Dieser eine Spieler hat die Stärke $100$, und ist somit der Stärkste der Spieler.
Wenn wir die Turnierformen $1000000$ mal simulieren, so ergeben sich für die Siegeswahrscheinlichkeiten des stärksten Spielers folgende Werte:

\

\begin{table}[H]
    \centering
\begin{tabular}{@{}cc@{}}
\toprule
Turnierform & Siegesrate                \\ \midrule
Liga        & \SI{11.5}{\percent}       \\
    Ko          & \SI{0.7}{\percent}       \\
    Kox5        & \SI{0.7}{\percent}       \\ \bottomrule
\end{tabular}
\end{table}

Turnierform Ko und Kox5 liefern hier sehr ähnliche Werte. Die Werte von Kox5 sind minimal besser. Liga liefert hier wieder die mit Abstand besten Werte.

\subsection{Quellcode}

\begin{figure}[H]
    \centering
\begin{lstlisting}
static Player league(ArrayList<Player> players) {
    
    boolean[][] played = new boolean[players.size()][players.size()];
    for(int i = 0; i < played.length; i++) {
        for(int j = 0; j < played.length; j++) {
            played[i][j] = false;
            played[j][i] = false;
            played[i][i] = true;
        }
    }
    
    boolean finished = true;
    do {
        finished = true;
        for(Player p1 : players) {
            for(Player p2 : players) {
                if(!played[p1.id][p2.id] && p1.id != p2.id) {
                    played[p1.id][p2.id] = true;
                    played[p2.id][p1.id] = true;
                    players.get(match(p1,p2).id).wins++;
                }
            }
        }

        for(Player p1 : players) {
            for(Player p2 : players) {
                if(!played[p1.id][p2.id])
                    finished = false;
            }
        }
    }while(!finished);

    int leading = 0;
    for(Player p : players) {
        if(p.wins > players.get(leading).wins) leading = p.id;
    }
    for(Player p : players) {
        p.wins = 0;
    }
    return players.get(leading);
}
\end{lstlisting}
\caption{Die Turnierform Liga}
\end{figure}

\begin{figure}[H]
    \centering
    \begin{lstlisting}
static Player ko(ArrayList<Player> players) {
    Node root;
    root = new Node();
    Collections.shuffle(players);
    root.create(players);
    Player winner = root.getWinner();
    for(Player p : players) {
        p.wins = 0;
    }
    sortById(players);
    return winner;
}

static Player kox5(ArrayList<Player> players) {
    Node root;
    root = new Node();
    Collections.shuffle(players);
    root.create(players);
    Player winner = root.getx5Winner();
    for(Player p : players) {
        p.wins = 0;
    }
    sortById(players);
    return winner;
}
    \end{lstlisting}
    \caption{Der beiden Methoden für Ko und Kox5}
\end{figure}

\begin{figure}[H]
\centering
\begin{lstlisting}
//Node für Binärbaum
//Erstellen des Baumes
public void create(ArrayList<Player> players) {
    if(players.size() == 2) {
        left = new Node(players.get(0));
        right = new Node(players.get(1));
    }
    else {
        left = new Node();
        right = new Node();
        int split = players.size() / 2;
        ArrayList<Player> forLeft = new ArrayList<>();
        ArrayList<Player> forRight = new ArrayList<>();
        for(int i = 0; i < split; i++) {
            forLeft.add(players.get(i));
            forRight.add(players.get(i+split));
        }
        left.create(forLeft);
        right.create(forRight);
    }
}
\end{lstlisting}
\caption{Die Klasse \emph{Node}}
\end{figure}

\begin{figure}[H]
\centering
\begin{lstlisting}
Player getWinner() {
    if(this.player != null) return this.player;
    else return match(left.getWinner(), right.getWinner());
}
Player getx5Winner() {
    if(this.player != null) return this.player;
    else return matchx5(left.getWinner(), right.getWinner());
}

public static Player match(Player p1, Player p2) {
int i = p1.strength + p2.strength;
int RNG = (int)(Math.random() * i);

if(RNG < p1.strength) return p1;
else return p2;
}

public static Player matchx5(Player p1, Player p2) {
for(int j = 0; j < 5; j++) {
    int i = p1.strength + p2.strength;
    int RNG = (int)(Math.random() * i);
    
    if(RNG < p1.strength) p1.wins++;
    else p2.wins++;
}
if(p1.wins > p2.wins) return p1;
else return p2;

}
\end{lstlisting}
\caption{Die Methoden der Klasse \emph{Node}}
\end{figure}

\begin{figure}[H]
\centering
\begin{lstlisting}
int best = getBest(players);
int bestWinsLeague = 0;
int bestWinsKo = 0;
int bestWinsKox5 = 0;

int iterations = 1000000;

for(int j = 0; j<iterations; j++) {
Player winnerLeague = league(players);
Player winnerKo = ko(players);
Player winnerKox5 = kox5(players);
for(Player p : players) {
    if(p.id == best && p == winnerLeague) {
        bestWinsLeague++;
    }
    if(p.id == best && p == winnerKo) {
        bestWinsKo++;
    }
    if(p.id == best && p == winnerKox5) {
        bestWinsKox5++;
    }
}
}
float winrateLeague = (float)bestWinsLeague/(float)iterations;
float winrateKo = (float)bestWinsKo/(float)iterations;
float winrateKox5 = (float)bestWinsKox5/(float)iterations;

System.out.println("Ligasiege: " + bestWinsLeague);
System.out.println("Ko-Siege: " + bestWinsKo);
System.out.println("Kox5-Siege: " + bestWinsKox5);


if(winrateLeague > winrateKo && winrateLeague > winrateKox5){
System.out.println("Das beste Turnierformat ist Liga, da der beste Spieler hier " + winrateLeague + " Prozent aller Ligen gewonnen hat);
}
else if(winrateKo > winrateKox5){
    System.out.println("Das beste Turnierformat ist Ko, da der beste Spieler hier " + winrateKox5 + " Prozent aller Ligen gewonnen hat);
}
else{
    System.out.println("Das beste Turnierformat ist Kox5, da der beste Spieler hier " + winrateKox5 + " Prozent aller Ligen gewonnen hat);
}

\end{lstlisting}
\caption{Die Auswertung der verschiedenen Turnierformen}
\end{figure}

\section{Wichteln}

\subsection{Lösungsidee}

Die Idee hinter unserem Programm ist, dass zuerst möglichst viele erstwünsche erfüllt werden. Erst wenn es keine erfüllbaren Erstwünsche mehr gibt werden die Zweitwünsche verteilt. Gibt es keine erfüllbaren Zweitwünsche mehr werden die Drittwünsche verteilt. Wurden alle Wünsche erfüllt werden die noch übrigen Geschenke zufällig auf die übrigen Schüler verteilt.

\subsection{Umsetzung}

Jeder Schüler wird durch die Klasse \emph{student} repräsentiert. Jeder Schüler speichert ob er bereits ein Geschenk erhalten hat und wenn ja, welches Geschenk er erhalten hat und welcher seiner Wünsche erfüllt wurde. Außerdem speichert der Schüler welche drei Wünsche er überhaupt hat.

\begin{figure}[h]
    \centering
    \begin{tikzpicture} 
        \umlclass{Student}{
            gifted: boolean\\
            metWish: int\\
            presentId: int\\
            wishes: int[]
        }{
            Student(wishes: int[])
        }
    \end{tikzpicture}
    \caption{Die Klasse \emph{Student}}
\end{figure}

Die Methode emph{distributePresents()} bekommt einmal die ganzen Schüler, dann die Geschenke und dann noch einen Integer übergeben. Diese Methode versucht den Wunsch den der Integer angibt bei allen Schülern mit den Geschenken zu erfüllen. Ist der übergebene int also zum Beispiel 0 erfüllt die Methode möglichst viele Erstwünsche der Schüler. Um dies zu erreichen läuft die Methode einmal über alle Schüler. Sollte der Schüler noch kein Geschenk haben und sein Geschenk an der Stelle des zu erfüllenden Wunsches noch nicht vergeben sein, so wird dem Schüler der Wunsch erfüllt.

\begin{figure}[H]
\centering
\begin{lstlisting}
    static void distributePresents(int n, Student[] students, boolean[] presents){
        for(int i = 0; i < students.length; i++){
            if(students[i].gifted) continue;
            if(presents[students[i].wishes[n]]) continue;
            students[i].gifted = true;
            students[i].metWish = n;
            students[i].presentId = students[i].wishes[n];
            presents[students[i].wishes[n]] = true;
        }
    }  
\end{lstlisting}
\caption{Die Methoden \emph{distributePresents()}}
\end{figure}

Nun wird diese Methode einmal für Wunsch 1, Wunsch 2 und Wunsch 3 aufgerufen. So werden zunächst möglichst viele Erstwünsche erfüllt, dann möglichst viele Zweitwünsche und dann noch möglichst viele Drittwünsche. Sobald diese Methode nun drei mal aufgerufen wurde gibt es immer noch Schüler, denen noch kein Geschenk zugeordnet wurde, da alle ihre Wünsche bereits vergeben sind. Um diesen Schülern auch noch ein Geschenk zu geben wird die Methode emph{fillLastWishes()} aufgerufen. Diese bekommt einmal die Schüler und einmal die Geschenke übergeben. Dann geht sie einfach noch alle Schüler durch und gibt den Schülern, die noch kein Geschenk bekommen haben das nächstbeste noch nicht vergebene Geschenk.

\begin{figure}[H]
\centering
\begin{lstlisting}
    static void fillLastWishes(Student[] students, boolean[] presents){
    	for(int i = 0; i < students.length; i++){
    		if(!students[i].gifted) {
    			for(int n = 0; n < students.length; n++){
    				if(!presents[n]){
    					students[i].gifted = true;
    					students[i].metWish = -1;
    	    			students[i].presentId = n;
    					presents[n] = true;
    					break;
    				}
    			}
			}
    	}
    }
\end{lstlisting}
\caption{Die Methoden \emph{distributePresents()}}
\end{figure}

Nach diesen Methodenaufrufen sind nun alle Geschenke möglichst gut verteilt, da möglichst viele Erstwünsche erfüllt wurden.

\subsection{Beispiele}


\end{document}