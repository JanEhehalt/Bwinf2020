\documentclass[a4paper, 12pt]{scrartcl}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage{fontspec}
\usepackage[ngerman]{babel}
\usepackage{setspace}
\usepackage{fancyhdr}
\usepackage{titling}
\usepackage{titlesec}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage[stable]{footmisc}
\usepackage{booktabs}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{ucs} % Einige Unicode Zeichen

\usepackage{float}

% Ein paar Mathe Sachen
\usepackage{amsmath,amssymb,amstext,mathtools}

\usepackage[hidelinks]{hyperref}
%\usepackage{hyperref}

%\usepackage[modulo]{lineno}
\usepackage{lineno}

\usepackage{tikz}
\usepackage{tikz-uml}
\usetikzlibrary{positioning}
\usetikzlibrary{graphs}

\pagestyle{fancy}

\fancyhf{}
\fancyhead[L]{}
\fancyhead[C]{\emph{\nouppercase\rightmark}}
\fancyhead[R]{}
\fancyfoot[C]{\thepage}

\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

\renewcommand{\familydefault}{\rmdefault}

\addtokomafont{labelinglabel}{\sffamily}

%\renewcommand{\maketitle}{
%  \begin{center}
%    {\huge \bfseries \thetitle}\\
%    \vspace{.25em}
%    {\Large \theauthor}
%  \end{center}
%}

\titleformat{\section}
{\Large \bfseries}
{\thesection \ }
{0em}
{}[\titlerule]

\titleformat{\subsection}
{\large \bfseries}
{\thesubsection \ }
{0em}
{}

\titleformat{\subsubsection}
{\bfseries}
{\thesubsubsection \ }
{0em}
{}

\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
language=Java,
numbers=left,
aboveskip=3mm,
belowskip=3mm,
showstringspaces=false,
columns=flexible,
basicstyle={\small\ttfamily},
numberstyle=\tiny\color{gray},
keywordstyle=\color{blue},
commentstyle=\color{dkgreen},
stringstyle=\color{mauve},
breaklines=true,
breakatwhitespace=true,
tabsize=3
}

\title{Dokumentation zu den Aufgaben des 39. Bundeswettbewerbs Informatik, 1. Runde}
\author{von Jan Ehehalt, Jonathan Hager}
\date{}

\begin{document}
\maketitle
\thispagestyle{empty}
\newpage
\tableofcontents
\thispagestyle{empty}
\newpage

\section{Allgemeine Informationen}

Da einige Methoden zu lang für eine Seite sind, wurde der Quellcode teilweise gekürzt. Die wichtigen Teile sind weiterhin enthalten. Auslassungen sind entsprechend mit {\glqq}[\dots]{\grqq} gekennzeichnet und mit einer kurzen Erklärung zur Funktion des ausgelassenen Codes versehen.

\section{Wörter aufräumen}
\subsection{Lösungsidee}
Es werden zwei Listen  angelegt,  die  jeweils  alle  Lücken  und  alle  einzufügenden  Wörter  getrennt speichern.  Das  Programm  geht  dann  alle  Lücken  durch  und  fügt  für  jede  Lücke,  bei  der  bereits  ein Buchstabe gegeben ist, ein eindeutig zuzuordnendes Wort ein. Das Programm achtet hierbei darauf, dass der gegebene Buchstabe, mit dem im Wort übereinstimmt, und dass das Wort genauso lang ist wie die Lücke. Sollte für eine Lücke mehr als ein Wort potenziell passen, so wird diese Lücke vorerst übersprungen.  Dieses  Verfahren  wird  dann  so  oft  ausgeführt,  bis  entweder  alle  Lücken  gefüllt  sind oder alle noch leeren Lücken keinen gegebenen Buchstaben mehr haben. Sobald es keine gegebenen Buchstaben  mehr  gibt werden  die  restlichen  Wörter  noch  anhand ihrer  Länge  den  übrigen  Lücken zugeordnet. So gibt es am Ende keine leeren Lücken mehr.

\subsection{Umsetzung}
Jede Lücke wird im Array \emph{sentence} als String gespeichert. Hierbei werden sowohl die Lücken, welche aus {\glqq}\_{\grqq} und verschiedenen Buchstaben bestehen können, als auch die Satzeichen, als eigene Elemente im Array gespeichert. Der \emph{words} Array speichert die Wörter, die in den Satz eingefügt werden müssen. Dann wird eine Schleife gestartet, die nun den Lücken Array mit Elementen  aus  dem  \emph{words}  Array  füllen  soll. Um  zu  erkennen  welche  Lücken  bereits  gefüllt  wurden, wird ein Array aus \emph{booleans} erstellt, der speichert welche Lücke bereits gefüllt wurde. Die Satzzeichen werden  hier  automatisch von Beginn an auf \emph{true}  gesetzt,  da  sie  nicht  gefüllt  werden  müssen. Dann iteriert  das  Programm über  alle  Wörter  und zählt in  wie  viele  noch  nicht  gefüllte  Lücken  das  Wort anhand  des  gegebenen  Buchstaben  und  der Länge  passen würde.  Sollte  das  Wort  in  nur  eine  Lücke passen,  so wird es  auch  in  diese eingefügt und aus  dem  \emph{words}  Array  entfernt. Sollte  das  Wort  in mehrere Lücken passen, so wird es zunächst übersprungen. Sobald einmal alle Wörter durchgegangen wurden wird noch einmal geprüft ob eines der Wörter in eine oder mehr Lücken passt. Sollte irgendein Wort  noch  eine  Lücke  finden,  der  es  eindeutig  zuzuordnen  ist,  so  wird  die  Schleife noch  nicht abgebrochen und startet  erneut. Dieses  ganz  Verfahren  läuft  also so  lange,  bis sich  kein Wort  mehr einer Lücke mithilfe eines Buchstaben zuordnen lässt. Sobald die Schleife beendet wurde kann es keine Lücke mehr geben, die einen gegebenen Buchstaben hat. Das einzige Mittel, um die Wörter zuzuordnen, ist nun also noch die Länge. Also iteriert das Programm wieder über alle Wörter und sucht für jedes Wort  eine  noch  nicht  gefüllte  Lücke,  die  genauso  lang  ist  wie  das  Wort.  Wenn  die  Lücke  gefunden wurde, wird das Wort hier eingefügt und aus dem \emph{words} Array gelöscht. Nach diesem Loop kann es nun keine ungefüllte Lücke mehr geben.

Um zu prüfen, ob ein Wort anhand des gegebenen Buchstaben und der Länge in eine Lücke passt, wird die Methode \emph{fits()} benutzt. Diese bekommt zwei Übergabeparameter. Einmal das Wort, welches in die Lücke eingefügt werden soll, und die Lücke, in die das Wort eingefügt werden soll. Diese Methode läuft zunächst  einmal  über  die  Lücke  und sucht nach  einem  gegebenen  Buchstaben,  dessen  Position im String der Lücke dann gespeichert wird. Sollte kein Buchstabe gefunden werden, so gibt die Methode \emph{false} zurück, da das Wort ja nicht eindeutig zuwiesen werden kann. Sollte ein Buchstaben gefunden worden  sein,  prüfen  wir  noch  im  einzufügenden  Wort,  ob  es  an  der  gleichen  Position  den  gleichen Buchstaben  hat  und  ob  die  Länge  der  beiden  Strings  übereinstimmen.  Da  jeder  Lücke  eindeutig ein Wort zuzuordnen sein muss, muss das Wort also in diese Lücke eingefügt werden, die Methode gibt \emph{true} zurück.

\subsection{Dokumentation der Beispiele}

\subsubsection{Selbsterstelltes Beispiel}
Die Funktion des Programms soll nochmal an folgendem Beispiel erläutert werden:
\begin{itemize}
    \item {\_}a{\_} {\_}{\_}s{\_} w{\_}{\_} {\_}{\_}{\_} {\_}{\_}d{\_}{\_}{\_} K{\_}{\_}{\_} !
    \item Pudels also war des Das Kern
\end{itemize}

Das Programm liest nun den Lückentext in den \emph{sentence} Array ein. Dieser hätte nun an der Stelle 2 zum Beispiel {\glqq}\_\_\_{\grqq} und an der Stelle 3 {\glqq}\_\_{\grqq}. Die einzufügenden Wörter werden im \emph{words} Array gespeichert. An der Stelle 2 zum Beispiel {\glqq}war{\grqq} und an der Stelle 3 {\glqq}des{\grqq}. Der \emph{sentence} Array hat nun eine Länge von 7 und \emph{words} 6. Nun läuft das Programm in der Schleife einmal über alle Wörter und zählt, wie vielen Lücken die Worte zugeordnet werden könnten. Das erste Wort {\glqq}Pudels{\grqq} findet für sich nur genau eine Lücke. Da es also eindeutig zuzuordnen ist wird es in Lücke 5 eingefügt und  aus  \emph{words} entfernt. Das  Wort {\glqq}also{\grqq} ist  eindeutig  der  zweiten  Lücke zuzuordnen. Das Wort {\glqq}war{\grqq} hat nun zwei Lücken, in die es anhand der gegebenen Buchstaben passen würde (Lücke 1 und 3). Deshalb wird es vorerst übersprungen. Das Wort {\glqq}des{\grqq} lässt sich mithilfe der gegebenen  Buchstaben  keiner  Lücke  eindeutig  zuordnen,  weshalb  es  auch  übersprungen  wird.  Das Wort {\glqq}Das{\grqq} lässt sich nun wieder eindeutig der ersten Lücke zuordnen, wird also auch eingefügt. {\glqq}Kern{\grqq} ist  auch  eindeutig  der  Lücke  6  zuzuordnen,  wird  also  eingefügt.  Nach  diesem  ersten  Durchgang  der Schleife sehen die Arrays also wie folgt aus:

\begin{labeling}{sentence}
    \item [sentence] Das also w{\_}{\_} {\_}{\_}{\_} Pudels Kern !
    \item [words] war des
\end{labeling}

Nun  wird  geprüft  ob  es  noch  Wörter  gibt,  die  sich  durch  gegebene  Buchstaben  noch  einer  Lücke zuordnen lassen. Da {\glqq}war{\grqq} noch eine Lücke findet wird die Schleife wiederholt. {\glqq}war{\grqq} lässt sich nun eindeutig der dritten Lücke zuordnen, da die andere Lücke, für die es auch gepasst hätte, ja nun bereits gefüllt  ist. Deshalb kann es nun in den Satz eingefügt werden. Das letzte Wort {\glqq}das{\grqq} ist nun keiner Lücke mehr zuzuordnen, weshalb die Schleife nun abbricht. Jetzt sehen die beiden Arrays so aus:

\begin{labeling}{sentence}
    \item [sentence] Das also war {\_}{\_}{\_} Pudels Kern !
    \item [words] des
\end{labeling}

Nun folgt noch der Loop, der die Wörter lediglich anhand ihrer Länge den Lücken zuordnet. Das Wort {\glqq}war{\grqq} ist nun das einzige Wort im \emph{words} Array. {\glqq}war{\grqq} hat eine Länge von 3. Nun wird im Satz nach einer noch nicht gefüllten Lücke der Länge 3 gesucht, welche an Stelle 4 gefunden wird. Somit gibt es nun kein Wort mehr im \emph{words} Array und \emph{sentence} sieht wie folgt aus:\\
Das also war des Pudels Kern !\\
Der Satz ist also fertig und wird ausgegeben.

\subsubsection{raetsel0}
Der fertige Satz lautet:\\
oh je, was für eine arbeit!

\subsubsection{raetsel1}
Der fertige Satz lautet:\\
Am Anfang wurde das Universum erschaffen. Das machte viele Leute sehr wütend und wurde allenthalben als Schritt in die falsche Richtung angesehen.

\subsubsection{raetsel2}
Der fertige Satz lautet:\\
Als Gregor Samsa eines Morgens aus unruhigen Träumen erwachte, fand er sich in seinem Bett zu einem ungeheuren Ungeziefer verwandelt.

\subsubsection{raetsel3}
Der fertige Satz lautet:\\
Informatik ist die Wissenschaft von der systematischen Darstellung, Speicherung, Verarbeitung und Übertragung von Informationen, besonders der automatischen Verarbeitung mit Digitalrechnern.

\subsubsection{raetsel4}
Der fertige Satz lautet:\\
Opa Jürgen blättert in einer Zeitschrift aus der Apotheke und findet ein Rätsel. Es ist eine Liste von Wörtern gegeben, die in die richtige Reihenfolge gebracht werden sollen, so dass sie eine lustige Geschichte ergeben. Leerzeichen und Satzzeichen sowie einige Buchstaben sind schon vorgegeben.

\section{Dreieckspuzzle}
\subsection{Lösungsidee}

Ein Algorithmus soll durch systematisches Probieren alle sinnvollen Möglichkeiten testen. Das Programm legt erst das erste Puzzleteil, versucht dann dessen anliegende Kanten mit Teilen zu füllen. Sollte es für ein Puzzleteil keine verfügbaren Teile mehr geben, die an die Kante passen, geht der Algorithmus mittels Backtracking zurück. Sobald er wieder zu einem Teil kommt, bei dem er andere Teile noch nicht probiert hat, versucht er das Puzzle ab hier wieder neu aufzubauen.

\subsection{Umsetzung}

Zur Darstellung der Struktur des Puzzle wird ein ungerichteter und ungewichteter Graph verwendet. Der Aufbau wird in Abbildung \ref{Graph1} gezeigt.

\begin{figure}[h]
    \centering
    \begin{subfigure}[t]{0.45\textwidth}
        \centering
    \begin{tikzpicture}[scale=1]
    %0
    \draw (-1,0) -- node[sloped,above]{1} (1,0); %mitte
    \draw (-1,0) -- node[sloped,above,rotate=180]{2} (0,1.73); %links
    \draw (1,0) -- node[sloped,above,rotate=180]{-2} (0,1.73); %rechts

    %1
    \draw (-2,-1.73) -- node[sloped,above]{1} (0,-1.73);
    \draw (-2,-1.73) -- node[sloped,above,rotate=180]{2} (-1,0);
    \draw (0,-1.73) -- node[sloped,above,rotate=180]{-2} (-1,0);

    %2
    \draw (-1,0) -- node[sloped,above,rotate=180]{1} (1,0);
    \draw (-1,0) -- node[sloped,above,rotate=0]{2} (0,-1.73);
    \draw (1,0) -- node[sloped,above,rotate=0]{-2} (0,-1.73);

    %3
    \draw (0,-1.73) -- node[sloped,above]{1} (2,-1.73);
    \draw (0,-1.73) -- node[sloped,above,rotate=180]{2} (1,0);
    \draw (2,-1.73) -- node[sloped,above,rotate=180]{-2} (1,0);

    %4
    \draw (-3,-3.46) -- node[sloped,above]{1} (-1,-3.46);
    \draw (-3,-3.46) -- node[sloped,above,rotate=180]{2} (-2,-1.73);
    \draw (-2,-1.73) -- node[sloped,above,rotate=180]{-2} (-1,-3.46);

    %5
    \draw (-2,-1.73) -- node[sloped,above,rotate=180]{1} (0,-1.73);
    \draw (-2,-1.73) -- node[sloped,above,rotate=0]{2} (-1,-3.46);
    \draw (0,-1.73) -- node[sloped,above,rotate=0]{-2} (-1,-3.46);

    %6
    \draw (-1,-3.46) -- node[sloped,above]{1} (1,-3.46);
    \draw (-1,-3.46) -- node[sloped,above,rotate=180]{2} (0,-1.73);
    \draw (1,-3.46) -- node[sloped,above,rotate=180]{-2} (0,-1.73);

    %7
    \draw (0,-1.73) -- node[sloped,above,rotate=180]{1} (2,-1.73);
    \draw (0,-1.73) -- node[sloped,above,rotate=0]{2} (1,-3.46);
    \draw (2,-1.73) -- node[sloped,above,rotate=0]{-2} (1,-3.46);

    %8
    \draw (1,-3.46) -- node[sloped,above]{1} (3,-3.46);
    \draw (1,-3.46) -- node[sloped,above,rotate=180]{2} (2,-1.73);
    \draw (3,-3.46) -- node[sloped,above,rotate=180]{-2} (2,-1.73);
    \end{tikzpicture}

        \subcaption{Das Puzzle}
    \end{subfigure}
\hfill
    \begin{subfigure}[t]{0.45\textwidth}
    \centering

    \begin{tikzpicture}
        \begin{scope}[every node/.style={circle,thick,draw}]
            \node (0) at (0,0) {0};
            \node (1) at (-1.5,-1.5) {1};
            \node (2) at (0,-1.5) {2};
            \node (3) at (1.5,-1.5) {3};
            \node (4) at (-3,-3) {4};
            \node (5) at (-1.5,-3) {5};
            \node (6) at (0,-3) {6};
            \node (7) at (1.5,-3) {7};
            \node (8) at (3,-3) {8};
        \end{scope}
        
        \begin{scope}
            %\path[-] (0) edge node[sloped,above]{Text} (2);
            \path[-] (0) edge (2);
            \path[-] (2) edge (1);
            \path[-] (2) edge (3);
            \path[-] (1) edge (5);
            \path[-] (4) edge (5);
            \path[-] (5) edge (6);
            \path[-] (6) edge (7);
            \path[-] (7) edge (3);
            \path[-] (7) edge (8);
        \end{scope}
    \end{tikzpicture}

        \subcaption{Darstellung als Graph}
        \label{Graph1.1}
    \end{subfigure}
    \caption{Interne Speicherung der Puzzlestruktur}
    \label{Graph1}
\end{figure}

Die Knoten bilden die einzelnen Puzzleteile. Wenn eine Kante im Graph existiert, dann berühren sich die beiden Puzzleteile auch im Puzzle, es muss also an den Stellen geprüft werden, ob sie zusammenpassen. Das ist der Fall, wenn beispielsweise die rechte Kante des einen Teils addiert mit der linken Kante des anderen Teils 0 ergibt.

Im Folgenden wird erst auf die einzelnen Klassen und deren Funktion eingegangen, anschließend wird die Vorgehensweise des Algorithmus anhand von Zeichnungen erläutert.

\subsubsection{Klassen}
\begin{figure}[h]
    \centering
    \begin{tikzpicture} 
        \umlclass{Tile}{
            $+$ values: int[]\\
            $+$ flipped: boolean
        }{
            $+$ rotate(): void\\
            $+$ flip(): void
        }
    \end{tikzpicture}
    \caption{Die Klasse \emph{Tile}}
    \label{tile}
\end{figure}

Die Klasse \emph{Tile} (Abbildung \ref{tile}) repräsentiert ein Puzzleteil. Dazu müssen die drei Kantenwerte gespeichert werden. Dies geschieht durch den Array \emph{values}. Die Seiten haben die Indizes wie folgt: $0$: links, $1$ mitte, $2$ rechts. Zudem muss gespeichert werden, ob ein Tile geflippt ist oder nicht. Dies ist nur bei den Stellen $2$, $5$, $7$ im Graph der Fall. Wenn ein Tile geflippt wird, müssen die Werte der linken und rechten Seite getauscht werden. Zudem muss das Tile in die andere Richtung rotiert werden. Die \emph{rotate()} Methode rotiert das Tile einmal um $120^\circ$.

\begin{figure}[h]
    \centering
    \begin{tikzpicture} 
        \umlclass{Graph}{
            $-$ matrix: int[][]\\
            $-$ tiles: Tile[]\\
            $-$ puzzle: int[]
        }{
            $+$ Graph(tiles: Tile[])\\
            $+$ fillWithTiles(): boolean\\
            $-$ fillBorders(tile: int): boolean\\
            $-$ fit(indexTiles: int, indexMatrix: int, rotations: int): boolean\\
            \dots
        }
    \end{tikzpicture}
    \caption{Die Klasse \emph{Graph}}
\end{figure}

Der Graph speichert seine Adjazenzmatrix, die als Wert $-1$, $0$ und $1$ annehmen kann. $-1$ bedeutet, dass diese Kante nicht existiert. Das ist der Fall, wenn sich die zwei Teile im echten Puzzle nicht berühren können, z.B. die rechte Kante der $0$ und die untere Kante der $4$. Den Wert $0$ nimmt eine Kante an, wenn diese aktuell nicht auf beiden Seiten besetzt ist, z.B. wenn in Abbildung \ref{Graph1.1} Teil 5 fehlen würde, hätten die Kanten 4-5, 1-5 und 5-6 den Wert $0$. Der Wert $1$ bedeutet, dass die Kante besetzt ist. Ist das Puzzle gelöst, haben also alle Kanten den Wert $-1$ oder $1$. $0$ würde bedeuten, dass es noch eine Kante gibt, die besetzt werden muss. Der Graph speichert im \emph{Tile} Array alle Puzzleteile, die es gibt. Der puzzle-Array speichert die Position jedes Teils im Graphen. Ist das Teil nicht im Graphen, hat puzzle an der Stelle des Teils den Wert $-1$.

Es wurden bewusst nicht alle Methoden in das Klassendiagramm übernommen, die wichtigen Methoden sind allerdings vorhanden. Die restlichen Methoden sind zur Erklärung des Algorithmus nicht von Bedeutung, sie fügen beispielsweise eine Kante am Anfang ein oder setzen das Puzzle zurück.

\subsubsection{Algorithmus}

Die Methode \emph{fillWithTiles()} wird aufgerufen, um das Puzzle zu lösen. Diese geht über jedes Puzzleteil und versucht das Puzzle damit an Stelle $0$ im Graphen zu lösen. Dazu wird \emph{fillBorders(0)} aufgerufen. Für den Quellcode der Methode, siehe Abbildung \ref{fillWithTiles}.

\begin{figure}[h]
    \centering

\begin{lstlisting}
public boolean fillWithTiles() {
	for(int i = 0; i < this.tiles.length; i++) {
		// puzzle-Array wird zurueckgesetzt
		resetPuzzle();

        // Das Tile wird an die Stelle 0 im Graph gesetzt
        puzzle[i] = 0;
		
        if(fillBorders(0)) {
            // Puzzle wurde gelöst
            return true;
        }
        // [...] fillBorders() wird für jede Rotation des Tile wiederholt
    }
	return false;
}
\end{lstlisting}

    \caption{Die Methode \emph{fillWithTiles()}}
    \label{fillWithTiles}
\end{figure}

Die Methode \emph{fillBorders(int)} versucht alle Kanten, die an die übergebene Stelle im Graphen, anliegen, zu füllen. Ob alles besetzt werden konnte, lässt sich am Rückgabewert \emph{true} oder \emph{false} erkennen. Dazu wird erst über die entsprechende Zeile in der Adjazenzmatrix iteriert. Nur beim Wert $0$ ist noch keine Kante vorhanden, also wird jetzt für diese Kante ein passendes Teil gesucht. Ob ein Teil bereits probiert wurde, wird im \emph{visited} Array geprüft. Dort wurde bereits die eigene Stelle und alle Teile, die im Graph sind, als \emph{true} markiert, damit diese nicht erneut probiert werden. Wenn ein passendes Teil gefunden wurde, wird dieses vorläufig eingefügt. Anschließend versucht dieses Teil seine Kanten zu füllen. Scheitert es, wird es entfernt und ein neues Teil gesucht. Ist es erfolgreich, geht die Methode zum nächsten Eintrag in der Zeile der Matrix und versucht diese ebenfalls zu füllen. Der Quellcode in Abbildung \ref{fillBorders} ist ein Teil der Methode. Dort wird zuerst mit \emph{fit()} überprüft, ob das Tile an die Stelle passt. Anschließend wird es dort eingefügt und versucht alle Kanten zu füllen, indem es \emph{fillBorders()} mit der eigenen Stelle im Graphen aufruft (\emph{puzzle} speichert für jedes Tile die Position im Graphen oder $-1$). $k$ ist das aktuelle Tile, $j$ die aktuelle Kante.

\begin{figure}[h]
    \centering

    \begin{lstlisting}
if(fit(k, j, 0)) {
	tileFound = true;
	resetTile(j);
	puzzle[k] = j;
	updateTrueLink(tile, j);
	placedTiles.add(j);
						
	if(fillBorders(puzzle[k])) {
		break;
	}
    else {
		resetTile(j);
		updateFalseLink(tile, j);
		tileFound = false;
	    continue;
    }
}
if(!tileFound) {
    // [...] alle vom Tile erstellten Tiles werden ebenfalls gelöscht
    return false;
}
return true;
    \end{lstlisting}

    \caption{Die Methode \emph{fillBorders}}
    \label{fillBorders}
\end{figure}

Die Methode \emph{fit()} prüft für eine gegebene Stelle im Graphen, ob ein gegebenes Puzzleteil passt. Zuerst wird geprüft, ob sich das Puzzleteil an der Stelle $2$, $5$ oder $7$ befindet. Ist dies der Fall, muss es geflippt werden. Im echten Puzzle äußert sich das an der Kante oben anstatt einer Spitze. Um zu wissen, welche Seiten bei zwei Teilen verglichen werden müssen, werden die beiden Stellen im Graph voneinander abgezogen. Kommt hier der Wert $-1$ raus, befindet sich das gefundene Teil rechts, bei $1$ links und bei jedem anderen Wert müssen die beiden mittleren Werte verglichen werden. Ist die Summe der beiden Kantenwerte der Teile $0$, passt das Puzzleteil. Der Quellcode, der eine Seite des Teils mit einer vorhandenen Kante vergleicht, ist in Abbildung \ref{fit} zu finden. $i$ ist der Index des zweiten Teils, mit dem verglichen werden muss.

\begin{figure}[h]
    \centering
\begin{lstlisting}
int difference = indexMatrix - i;
int side1 = 1;
int side2 = 1;
int tile2 = getIndexTiles(i);
			
if(difference == -1) {
    side1 = 2;
	side2 = 0;
}
else if(difference == 1) {
	side1 = 0;
	side2 = 2;
}	

if(tiles[indexTiles].values[side1] + tiles[tile2].values[side2] != 0) {
    fits = false;
    break;
}
\end{lstlisting}
    \caption{Ausschnitt von \emph{fit()}}
    \label{fit}
\end{figure}

\subsection{Beispiele}
\subsubsection{Puzzle0}

In der folgenden Reihe an Abbildungen wird das Beispiel von \emph{puzzle0.txt} verwendet. Es wird gezeigt, wie sich die richtige Lösung stückweise aufbaut. Allerdings wird jegliche Rotation und Backtracking, wegen der Übersichtlichkeit, nicht dargestellt. Man soll lediglich erkennen können, wie sich der Graph bzw. das Puzzle stückweise aufbauen. Die Pfeile am Graphen stehen nicht für eine Richtung oder alle Kanten, sie sollen lediglich veranschaulichen, welches Teil welches gelegt hat.

\begin{figure}[H]
    \centering
    \begin{subfigure}[t]{0.45\textwidth}
        \centering
    \begin{tikzpicture}[scale=1]
    %0
    \draw (-1,0) -- node[sloped,above]{-2} (1,0); %mitte
    \draw (-1,0) -- node[sloped,above,rotate=180]{-1} (0,1.73); %links
    \draw (1,0) -- node[sloped,above,rotate=180]{2} (0,1.73); %rechts

    \end{tikzpicture}
    \end{subfigure}
\hfill
    \begin{subfigure}[t]{0.45\textwidth}
    \centering

    \begin{tikzpicture}
        \begin{scope}[every node/.style={circle,thick,draw}]
            \node (0) at (0,0) {0};
        \end{scope}
        
        \begin{scope}
            %\path[-] (0) edge node[sloped,above]{Text} (2);
        \end{scope}
    \end{tikzpicture}
    \end{subfigure}
    \caption{Teil 0 wird gelegt}
\end{figure}

\begin{figure}[H]
    \centering
    \begin{subfigure}[t]{0.45\textwidth}
        \centering
    \begin{tikzpicture}[scale=1]
    %0
    \draw (-1,0) -- node[sloped,above]{-2} (1,0); %mitte
    \draw (-1,0) -- node[sloped,above,rotate=180]{-1} (0,1.73); %links
    \draw (1,0) -- node[sloped,above,rotate=180]{2} (0,1.73); %rechts

    %2
    \draw (-1,0) -- node[sloped,above,rotate=180]{2} (1,0);
    \draw (-1,0) -- node[sloped,above,rotate=0]{-1} (0,-1.73);
    \draw (1,0) -- node[sloped,above,rotate=0]{2} (0,-1.73);

    \end{tikzpicture}
    \end{subfigure}
\hfill
    \begin{subfigure}[t]{0.45\textwidth}
    \centering

    \begin{tikzpicture}
        \begin{scope}[every node/.style={circle,thick,draw}]
            \node (0) at (0,0) {0};
            \node (2) at (0,-1.5) {2};
        \end{scope}
        
        \begin{scope}
            %\path[-] (0) edge node[sloped,above]{Text} (2);
            \path[->] (0) edge (2);
        \end{scope}
    \end{tikzpicture}

    \end{subfigure}
    \caption{Teil 2 wird von 0 gelegt}
\end{figure}

\begin{figure}[H]
    \centering
    \begin{subfigure}[t]{0.45\textwidth}
        \centering
    \begin{tikzpicture}[scale=1]
    %0
    \draw (-1,0) -- node[sloped,above]{-2} (1,0); %mitte
    \draw (-1,0) -- node[sloped,above,rotate=180]{-1} (0,1.73); %links
    \draw (1,0) -- node[sloped,above,rotate=180]{2} (0,1.73); %rechts

    %1
    \draw (-2,-1.73) -- node[sloped,above]{3} (0,-1.73);
    \draw (-2,-1.73) -- node[sloped,above,rotate=180]{-1} (-1,0);
    \draw (0,-1.73) -- node[sloped,above,rotate=180]{1} (-1,0);

    %2
    \draw (-1,0) -- node[sloped,above,rotate=180]{2} (1,0);
    \draw (-1,0) -- node[sloped,above,rotate=0]{-1} (0,-1.73);
    \draw (1,0) -- node[sloped,above,rotate=0]{2} (0,-1.73);
    \end{tikzpicture}
    \end{subfigure}
\hfill
    \begin{subfigure}[t]{0.45\textwidth}
    \centering

    \begin{tikzpicture}
        \begin{scope}[every node/.style={circle,thick,draw}]
            \node (0) at (0,0) {0};
            \node (1) at (-1.5,-1.5) {1};
            \node (2) at (0,-1.5) {2};
        \end{scope}
        
        \begin{scope}
            %\path[-] (0) edge node[sloped,above]{Text} (2);
            \path[->] (0) edge (2);
            \path[->] (2) edge (1);
        \end{scope}
    \end{tikzpicture}
    \end{subfigure}
    \caption{Teil 1 wird von 2 gelegt}
    \label{Graph1}
\end{figure}

\begin{figure}[H]
    \centering
    \begin{subfigure}[t]{0.45\textwidth}
        \centering
    \begin{tikzpicture}[scale=1]
    %0
    \draw (-1,0) -- node[sloped,above]{-2} (1,0); %mitte
    \draw (-1,0) -- node[sloped,above,rotate=180]{-1} (0,1.73); %links
    \draw (1,0) -- node[sloped,above,rotate=180]{2} (0,1.73); %rechts

    %1
    \draw (-2,-1.73) -- node[sloped,above]{3} (0,-1.73);
    \draw (-2,-1.73) -- node[sloped,above,rotate=180]{-1} (-1,0);
    \draw (0,-1.73) -- node[sloped,above,rotate=180]{1} (-1,0);

    %2
    \draw (-1,0) -- node[sloped,above,rotate=180]{2} (1,0);
    \draw (-1,0) -- node[sloped,above,rotate=0]{-1} (0,-1.73);
    \draw (1,0) -- node[sloped,above,rotate=0]{2} (0,-1.73);

    %5
    \draw (-2,-1.73) -- node[sloped,above,rotate=180]{-3} (0,-1.73);
    \draw (-2,-1.73) -- node[sloped,above,rotate=0]{3} (-1,-3.46);
    \draw (0,-1.73) -- node[sloped,above,rotate=0]{2} (-1,-3.46);

    \end{tikzpicture}

    \end{subfigure}
\hfill
    \begin{subfigure}[t]{0.45\textwidth}
    \centering

    \begin{tikzpicture}
        \begin{scope}[every node/.style={circle,thick,draw}]
            \node (0) at (0,0) {0};
            \node (1) at (-1.5,-1.5) {1};
            \node (2) at (0,-1.5) {2};
            \node (5) at (-1.5,-3) {5};
        \end{scope}
        
        \begin{scope}
            %\path[-] (0) edge node[sloped,above]{Text} (2);
            \path[->] (0) edge (2);
            \path[->] (2) edge (1);
            \path[->] (1) edge (5);
        \end{scope}
    \end{tikzpicture}

    \end{subfigure}
    \caption{Teil 5 wird von 1 angelegt}
\end{figure}

\begin{figure}[H]
    \centering
    \begin{subfigure}[t]{0.45\textwidth}
        \centering
    \begin{tikzpicture}[scale=1]
    %0
    \draw (-1,0) -- node[sloped,above]{-2} (1,0); %mitte
    \draw (-1,0) -- node[sloped,above,rotate=180]{-1} (0,1.73); %links
    \draw (1,0) -- node[sloped,above,rotate=180]{2} (0,1.73); %rechts

    %1
    \draw (-2,-1.73) -- node[sloped,above]{3} (0,-1.73);
    \draw (-2,-1.73) -- node[sloped,above,rotate=180]{-1} (-1,0);
    \draw (0,-1.73) -- node[sloped,above,rotate=180]{1} (-1,0);

    %2
    \draw (-1,0) -- node[sloped,above,rotate=180]{2} (1,0);
    \draw (-1,0) -- node[sloped,above,rotate=0]{-1} (0,-1.73);
    \draw (1,0) -- node[sloped,above,rotate=0]{2} (0,-1.73);

    %4
    \draw (-3,-3.46) -- node[sloped,above]{-1} (-1,-3.46);
    \draw (-3,-3.46) -- node[sloped,above,rotate=180]{2} (-2,-1.73);
    \draw (-2,-1.73) -- node[sloped,above,rotate=180]{-3} (-1,-3.46);

    %5
    \draw (-2,-1.73) -- node[sloped,above,rotate=180]{-3} (0,-1.73);
    \draw (-2,-1.73) -- node[sloped,above,rotate=0]{3} (-1,-3.46);
    \draw (0,-1.73) -- node[sloped,above,rotate=0]{2} (-1,-3.46);

    \end{tikzpicture}

    \end{subfigure}
\hfill
    \begin{subfigure}[t]{0.45\textwidth}
    \centering

    \begin{tikzpicture}
        \begin{scope}[every node/.style={circle,thick,draw}]
            \node (0) at (0,0) {0};
            \node (1) at (-1.5,-1.5) {1};
            \node (2) at (0,-1.5) {2};
            \node (4) at (-3,-3) {4};
            \node (5) at (-1.5,-3) {5};
        \end{scope}
        
        \begin{scope}
            %\path[-] (0) edge node[sloped,above]{Text} (2);
            \path[->] (0) edge (2);
            \path[->] (2) edge (1);
            \path[->] (1) edge (5);
            \path[->] (5) edge (4);
        \end{scope}
    \end{tikzpicture}

    \end{subfigure}
    \caption{Teil 4 wird von 5 angelegt}
\end{figure}

\begin{figure}[H]
    \centering
    \begin{subfigure}[t]{0.45\textwidth}
        \centering
    \begin{tikzpicture}[scale=1]
    %0
    \draw (-1,0) -- node[sloped,above]{-2} (1,0); %mitte
    \draw (-1,0) -- node[sloped,above,rotate=180]{-1} (0,1.73); %links
    \draw (1,0) -- node[sloped,above,rotate=180]{2} (0,1.73); %rechts

    %1
    \draw (-2,-1.73) -- node[sloped,above]{3} (0,-1.73);
    \draw (-2,-1.73) -- node[sloped,above,rotate=180]{-1} (-1,0);
    \draw (0,-1.73) -- node[sloped,above,rotate=180]{1} (-1,0);

    %2
    \draw (-1,0) -- node[sloped,above,rotate=180]{2} (1,0);
    \draw (-1,0) -- node[sloped,above,rotate=0]{-1} (0,-1.73);
    \draw (1,0) -- node[sloped,above,rotate=0]{2} (0,-1.73);

    %4
    \draw (-3,-3.46) -- node[sloped,above]{-1} (-1,-3.46);
    \draw (-3,-3.46) -- node[sloped,above,rotate=180]{2} (-2,-1.73);
    \draw (-2,-1.73) -- node[sloped,above,rotate=180]{-3} (-1,-3.46);

    %5
    \draw (-2,-1.73) -- node[sloped,above,rotate=180]{-3} (0,-1.73);
    \draw (-2,-1.73) -- node[sloped,above,rotate=0]{3} (-1,-3.46);
    \draw (0,-1.73) -- node[sloped,above,rotate=0]{2} (-1,-3.46);

    %6
    \draw (-1,-3.46) -- node[sloped,above]{1} (1,-3.46);
    \draw (-1,-3.46) -- node[sloped,above,rotate=180]{-2} (0,-1.73);
    \draw (1,-3.46) -- node[sloped,above,rotate=180]{-3} (0,-1.73);

    \end{tikzpicture}

    \end{subfigure}
\hfill
    \begin{subfigure}[t]{0.45\textwidth}
    \centering

    \begin{tikzpicture}
        \begin{scope}[every node/.style={circle,thick,draw}]
            \node (0) at (0,0) {0};
            \node (1) at (-1.5,-1.5) {1};
            \node (2) at (0,-1.5) {2};
            \node (4) at (-3,-3) {4};
            \node (5) at (-1.5,-3) {5};
            \node (6) at (0,-3) {6};
        \end{scope}
        
        \begin{scope}
            %\path[-] (0) edge node[sloped,above]{Text} (2);
            \path[->] (0) edge (2);
            \path[->] (2) edge (1);
            \path[->] (1) edge (5);
            \path[->] (5) edge (4);
            \path[->] (5) edge (6);
        \end{scope}
    \end{tikzpicture}

    \end{subfigure}
    \caption{Teil 6 wird von 5 angelegt}
\end{figure}

\begin{figure}[H]
    \centering
    \begin{subfigure}[t]{0.45\textwidth}
        \centering
    \begin{tikzpicture}[scale=1]
    %0
    \draw (-1,0) -- node[sloped,above]{-2} (1,0); %mitte
    \draw (-1,0) -- node[sloped,above,rotate=180]{-1} (0,1.73); %links
    \draw (1,0) -- node[sloped,above,rotate=180]{2} (0,1.73); %rechts

    %1
    \draw (-2,-1.73) -- node[sloped,above]{3} (0,-1.73);
    \draw (-2,-1.73) -- node[sloped,above,rotate=180]{-1} (-1,0);
    \draw (0,-1.73) -- node[sloped,above,rotate=180]{1} (-1,0);

    %2
    \draw (-1,0) -- node[sloped,above,rotate=180]{2} (1,0);
    \draw (-1,0) -- node[sloped,above,rotate=0]{-1} (0,-1.73);
    \draw (1,0) -- node[sloped,above,rotate=0]{2} (0,-1.73);

    %4
    \draw (-3,-3.46) -- node[sloped,above]{-1} (-1,-3.46);
    \draw (-3,-3.46) -- node[sloped,above,rotate=180]{2} (-2,-1.73);
    \draw (-2,-1.73) -- node[sloped,above,rotate=180]{-3} (-1,-3.46);

    %5
    \draw (-2,-1.73) -- node[sloped,above,rotate=180]{-3} (0,-1.73);
    \draw (-2,-1.73) -- node[sloped,above,rotate=0]{3} (-1,-3.46);
    \draw (0,-1.73) -- node[sloped,above,rotate=0]{2} (-1,-3.46);

    %6
    \draw (-1,-3.46) -- node[sloped,above]{1} (1,-3.46);
    \draw (-1,-3.46) -- node[sloped,above,rotate=180]{-2} (0,-1.73);
    \draw (1,-3.46) -- node[sloped,above,rotate=180]{-3} (0,-1.73);

    %7
    \draw (0,-1.73) -- node[sloped,above,rotate=180]{-1} (2,-1.73);
    \draw (0,-1.73) -- node[sloped,above,rotate=0]{3} (1,-3.46);
    \draw (2,-1.73) -- node[sloped,above,rotate=0]{-2} (1,-3.46);

    \end{tikzpicture}

    \end{subfigure}
\hfill
    \begin{subfigure}[t]{0.45\textwidth}
    \centering

    \begin{tikzpicture}
        \begin{scope}[every node/.style={circle,thick,draw}]
            \node (0) at (0,0) {0};
            \node (1) at (-1.5,-1.5) {1};
            \node (2) at (0,-1.5) {2};
            \node (4) at (-3,-3) {4};
            \node (5) at (-1.5,-3) {5};
            \node (6) at (0,-3) {6};
            \node (7) at (1.5,-3) {7};
        \end{scope}
        
        \begin{scope}
            %\path[-] (0) edge node[sloped,above]{Text} (2);
            \path[->] (0) edge (2);
            \path[->] (2) edge (1);
            \path[->] (1) edge (5);
            \path[->] (5) edge (4);
            \path[->] (5) edge (6);
            \path[->] (6) edge (7);
        \end{scope}
    \end{tikzpicture}

    \end{subfigure}
    \caption{Teil 7 wird von 6 angelegt}
\end{figure}

\begin{figure}[H]
    \centering
    \begin{subfigure}[t]{0.45\textwidth}
        \centering
    \begin{tikzpicture}[scale=1]
    %0
    \draw (-1,0) -- node[sloped,above]{-2} (1,0); %mitte
    \draw (-1,0) -- node[sloped,above,rotate=180]{-1} (0,1.73); %links
    \draw (1,0) -- node[sloped,above,rotate=180]{2} (0,1.73); %rechts

    %1
    \draw (-2,-1.73) -- node[sloped,above]{3} (0,-1.73);
    \draw (-2,-1.73) -- node[sloped,above,rotate=180]{-1} (-1,0);
    \draw (0,-1.73) -- node[sloped,above,rotate=180]{1} (-1,0);

    %2
    \draw (-1,0) -- node[sloped,above,rotate=180]{2} (1,0);
    \draw (-1,0) -- node[sloped,above,rotate=0]{-1} (0,-1.73);
    \draw (1,0) -- node[sloped,above,rotate=0]{2} (0,-1.73);

    %3
    \draw (0,-1.73) -- node[sloped,above]{1} (2,-1.73);
    \draw (0,-1.73) -- node[sloped,above,rotate=180]{-2} (1,0);
    \draw (2,-1.73) -- node[sloped,above,rotate=180]{-1} (1,0);

    %4
    \draw (-3,-3.46) -- node[sloped,above]{-1} (-1,-3.46);
    \draw (-3,-3.46) -- node[sloped,above,rotate=180]{2} (-2,-1.73);
    \draw (-2,-1.73) -- node[sloped,above,rotate=180]{-3} (-1,-3.46);

    %5
    \draw (-2,-1.73) -- node[sloped,above,rotate=180]{-3} (0,-1.73);
    \draw (-2,-1.73) -- node[sloped,above,rotate=0]{3} (-1,-3.46);
    \draw (0,-1.73) -- node[sloped,above,rotate=0]{2} (-1,-3.46);

    %6
    \draw (-1,-3.46) -- node[sloped,above]{1} (1,-3.46);
    \draw (-1,-3.46) -- node[sloped,above,rotate=180]{-2} (0,-1.73);
    \draw (1,-3.46) -- node[sloped,above,rotate=180]{-3} (0,-1.73);

    %7
    \draw (0,-1.73) -- node[sloped,above,rotate=180]{-1} (2,-1.73);
    \draw (0,-1.73) -- node[sloped,above,rotate=0]{3} (1,-3.46);
    \draw (2,-1.73) -- node[sloped,above,rotate=0]{-2} (1,-3.46);

    \end{tikzpicture}

    \end{subfigure}
\hfill
    \begin{subfigure}[t]{0.45\textwidth}
    \centering

    \begin{tikzpicture}
        \begin{scope}[every node/.style={circle,thick,draw}]
            \node (0) at (0,0) {0};
            \node (1) at (-1.5,-1.5) {1};
            \node (2) at (0,-1.5) {2};
            \node (3) at (1.5,-1.5) {3};
            \node (4) at (-3,-3) {4};
            \node (5) at (-1.5,-3) {5};
            \node (6) at (0,-3) {6};
            \node (7) at (1.5,-3) {7};
        \end{scope}
        
        \begin{scope}
            %\path[-] (0) edge node[sloped,above]{Text} (2);
            \path[->] (0) edge (2);
            \path[->] (2) edge (1);
            \path[->] (1) edge (5);
            \path[->] (5) edge (4);
            \path[->] (5) edge (6);
            \path[->] (6) edge (7);
            \path[->] (7) edge (3);
        \end{scope}
    \end{tikzpicture}

    \end{subfigure}
    \caption{Teil 3 wird von 7 angelegt}
\end{figure}

\begin{figure}[H]
    \centering
    \begin{subfigure}[t]{0.45\textwidth}
        \centering
    \begin{tikzpicture}[scale=1]
    %0
    \draw (-1,0) -- node[sloped,above]{-2} (1,0); %mitte
    \draw (-1,0) -- node[sloped,above,rotate=180]{-1} (0,1.73); %links
    \draw (1,0) -- node[sloped,above,rotate=180]{2} (0,1.73); %rechts

    %1
    \draw (-2,-1.73) -- node[sloped,above]{3} (0,-1.73);
    \draw (-2,-1.73) -- node[sloped,above,rotate=180]{-1} (-1,0);
    \draw (0,-1.73) -- node[sloped,above,rotate=180]{1} (-1,0);

    %2
    \draw (-1,0) -- node[sloped,above,rotate=180]{2} (1,0);
    \draw (-1,0) -- node[sloped,above,rotate=0]{-1} (0,-1.73);
    \draw (1,0) -- node[sloped,above,rotate=0]{2} (0,-1.73);

    %3
    \draw (0,-1.73) -- node[sloped,above]{1} (2,-1.73);
    \draw (0,-1.73) -- node[sloped,above,rotate=180]{-2} (1,0);
    \draw (2,-1.73) -- node[sloped,above,rotate=180]{-1} (1,0);

    %4
    \draw (-3,-3.46) -- node[sloped,above]{-1} (-1,-3.46);
    \draw (-3,-3.46) -- node[sloped,above,rotate=180]{2} (-2,-1.73);
    \draw (-2,-1.73) -- node[sloped,above,rotate=180]{-3} (-1,-3.46);

    %5
    \draw (-2,-1.73) -- node[sloped,above,rotate=180]{-3} (0,-1.73);
    \draw (-2,-1.73) -- node[sloped,above,rotate=0]{3} (-1,-3.46);
    \draw (0,-1.73) -- node[sloped,above,rotate=0]{2} (-1,-3.46);

    %6
    \draw (-1,-3.46) -- node[sloped,above]{1} (1,-3.46);
    \draw (-1,-3.46) -- node[sloped,above,rotate=180]{-2} (0,-1.73);
    \draw (1,-3.46) -- node[sloped,above,rotate=180]{-3} (0,-1.73);

    %7
    \draw (0,-1.73) -- node[sloped,above,rotate=180]{-1} (2,-1.73);
    \draw (0,-1.73) -- node[sloped,above,rotate=0]{3} (1,-3.46);
    \draw (2,-1.73) -- node[sloped,above,rotate=0]{-2} (1,-3.46);

    %8
    \draw (1,-3.46) -- node[sloped,above]{-1} (3,-3.46);
    \draw (1,-3.46) -- node[sloped,above,rotate=180]{2} (2,-1.73);
    \draw (3,-3.46) -- node[sloped,above,rotate=180]{-1} (2,-1.73);

    \end{tikzpicture}
    \end{subfigure}
\hfill
    \begin{subfigure}[t]{0.45\textwidth}
    \centering

    \begin{tikzpicture}
        \begin{scope}[every node/.style={circle,thick,draw}]
            \node (0) at (0,0) {0};
            \node (1) at (-1.5,-1.5) {1};
            \node (2) at (0,-1.5) {2};
            \node (3) at (1.5,-1.5) {3};
            \node (4) at (-3,-3) {4};
            \node (5) at (-1.5,-3) {5};
            \node (6) at (0,-3) {6};
            \node (7) at (1.5,-3) {7};
            \node (8) at (3,-3) {8};
        \end{scope}
        
        \begin{scope}
            %\path[-] (0) edge node[sloped,above]{Text} (2);
            \path[->] (0) edge (2);
            \path[->] (2) edge (1);
            \path[->] (1) edge (5);
            \path[->] (5) edge (4);
            \path[->] (5) edge (6);
            \path[->] (6) edge (7);
            \path[->] (7) edge (3);
            \path[->] (7) edge (8);
        \end{scope}
    \end{tikzpicture}
    \end{subfigure}
    \caption{Teil 8 wird von 7 angelegt}
\end{figure}

\subsubsection{Puzzle1}

Laut dem Algorithmus ist dieses Puzzle nicht lösbar.

\subsubsection{Puzzle2}

Dieses Puzzle ist lösbar. Die Lösung ist in Abbildung \ref{puzzle2} dargestellt.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[scale=1]
    %0
    \draw (-1,0) -- node[sloped,above]{-2} (1,0); %mitte
    \draw (-1,0) -- node[sloped,above,rotate=180]{1} (0,1.73); %links
    \draw (1,0) -- node[sloped,above,rotate=180]{-4} (0,1.73); %rechts

    %1
    \draw (-2,-1.73) -- node[sloped,above]{-1} (0,-1.73);
    \draw (-2,-1.73) -- node[sloped,above,rotate=180]{-2} (-1,0);
    \draw (0,-1.73) -- node[sloped,above,rotate=180]{-3} (-1,0);

    %2
    \draw (-1,0) -- node[sloped,above,rotate=180]{2} (1,0);
    \draw (-1,0) -- node[sloped,above,rotate=0]{3} (0,-1.73);
    \draw (1,0) -- node[sloped,above,rotate=0]{1} (0,-1.73);

    %3
    \draw (0,-1.73) -- node[sloped,above]{1} (2,-1.73);
    \draw (0,-1.73) -- node[sloped,above,rotate=180]{-1} (1,0);
    \draw (2,-1.73) -- node[sloped,above,rotate=180]{-3} (1,0);

    %4
    \draw (-3,-3.46) -- node[sloped,above]{1} (-1,-3.46);
    \draw (-3,-3.46) -- node[sloped,above,rotate=180]{-3} (-2,-1.73);
    \draw (-2,-1.73) -- node[sloped,above,rotate=180]{-2} (-1,-3.46);

    %5
    \draw (-2,-1.73) -- node[sloped,above,rotate=180]{1} (0,-1.73);
    \draw (-2,-1.73) -- node[sloped,above,rotate=0]{2} (-1,-3.46);
    \draw (0,-1.73) -- node[sloped,above,rotate=0]{-4} (-1,-3.46);

    %6
    \draw (-1,-3.46) -- node[sloped,above]{-2} (1,-3.46);
    \draw (-1,-3.46) -- node[sloped,above,rotate=180]{4} (0,-1.73);
    \draw (1,-3.46) -- node[sloped,above,rotate=180]{-3} (0,-1.73);

    %7
    \draw (0,-1.73) -- node[sloped,above,rotate=180]{-1} (2,-1.73);
    \draw (0,-1.73) -- node[sloped,above,rotate=0]{3} (1,-3.46);
    \draw (2,-1.73) -- node[sloped,above,rotate=0]{4} (1,-3.46);

    %8
    \draw (1,-3.46) -- node[sloped,above]{-3} (3,-3.46);
    \draw (1,-3.46) -- node[sloped,above,rotate=180]{-4} (2,-1.73);
    \draw (3,-3.46) -- node[sloped,above,rotate=180]{-2} (2,-1.73);

    \end{tikzpicture}
    \caption{Die Lösung von Puzzle2}
    \label{puzzle2}
\end{figure}

\subsubsection{Puzzle3}

Laut dem Algorithmus ist dieses Puzzle nicht lösbar.

\section{Tobis Turnier}

\section{Streichholzrätsel}
\section{Wichteln}
\subsection{Lösungsidee}

Im Wesentlichen ist das Problem der Zuordnung mit dem \emph{Stable Marriage Problem} vergleichbar. Es gibt zwei verschiedene Gruppen, die so gut wie möglich verteilt werden müssen. Deshalb lässt sich die Aufgabe mit einer leicht angepassten Variante des \emph{Gale-Shapley} Algorithmus lösen. Allgemein fragen alle Schüler ohne Geschenk bei den Geschenken an, ob diese noch keinen Partner haben oder den neuen Partner dem aktuellen vorziehen. Dabei wird ein Erstwunsch allem vorgezogen, dann folgen Zweitwunsch, Drittwunsch und zuletzt eine Zuteilung ohne Wunsch. Jeder Schüler fragt nacheinander seine Wünsche an. Sollte er danach noch kein Geschenk haben, versucht er ein übriges Geschenk zu bekommen.

\subsection{Umsetzung}

\begin{figure}[h]
    \centering
    \begin{tikzpicture} 
        \umlclass{Student}{
            hasGift: boolean\\
            index: int\\
            presentId: int\\
            wishes: int[]\\
            asked: boolean[]
        }{
            Student(int[], int, int)\\
            requestPresent(Present[], Student[], int, int): void
        }
    \end{tikzpicture}
    \caption{Die Klasse \emph{Student}}
\end{figure}

Jeder Schüler wird durch ein Objekt der Klasse \emph{Student} repräsentiert. Dabei muss jeder Schüler speichern, ob er bereits ein Geschenk hat. Zudem weiß jeder Schüler, welche Geschenk er als Erst-, Zweit- und Drittwunsch will. Für den Algorithmus ist es notwendig, dass jeder Schüler zusätzlich seine Position im Array und alle Geschenke, die er schon versucht hat zu bekommen, kennt. Der Schüler braucht \emph{requestPresent()} als einzige Methode. Übergeben bekommt er zum einen den \emph{Present} und \emph{Student} Array, zum anderen den Index des entsprechenden Geschenks, sowie den Grad des Wunsches. Hierbei hat ein Erstwunsch den Grad 0, ein Zweitwunsch 1, ein Drittwunsch 2 und eine reine Zuteilung 3. Diesen Grad braucht das Geschenk, um den neuen Schüler mit dem möglicherweise aktuellen Schüler zu vergleichen und zu ermitteln, welchen Schüler es bevorzugt.

\begin{figure}[h]
    \centering
    \begin{tikzpicture} 
        \umlclass{Present}{
            studentId: int\\
            wish: int
        }{
            Present()\\
            changeStudent(students: Student[], wish: int, studentId: int): boolean
        }
    \end{tikzpicture}
    \caption{Die Klasse \emph{Present}}
\end{figure}

Die Geschenke werden von der Klasse \emph{Present} repräsentiert. Ein Geschenk muss hierfür wissen, an welchen Schüler es vergeben ist. Dazu wird der Index des Schülers gespeichert. Um zwei Schüler vergleichen zu können, muss zudem bekannt sein, welchen Grad der Wunsch des aktuellen Schülers hat. Dieser wird als \emph{int} gespeichert. Damit der Algorithmus funktioniert, muss das Geschenk seinen Schüler wechseln können. Hierfür wird der \emph{Student} Array übergeben, sowie der Grad des Wunsches vom neuen Schüler und der Index des neuen Schülers. Die Methode gibt durch einen \emph{boolean} zurück, ob der übergebene Schüler übernommen oder abgelehnt wurde. Die Methode arbeitet wie folgt:

\begin{figure}[h]
\centering
\begin{lstlisting}
boolean changeStudent(Student[] students, int wish, int studentId) {
	if(this.wish > wish){
		if(this.studentId >= 0) {
			students[this.studentId].hasGift = false;
		}

		this.studentId = studentId;
		this.wish = wish;
		students[studentId].hasGift = true;
			
		return true;
	}
	else {
		return false;
	}
}
\end{lstlisting}
\caption{Die Methode \emph{changeStudent()}}
\end{figure}

Zuerst wird verglichen, ob der Grad des gespeicherten Wunsches größer ist, als der des neuen Schülers. Ein kleinerer Grad ist immer einem größeren vorzuziehen. Ist der Grad des neuen Wunsches also nicht echt kleiner als der bisherige, gibt die Methode direkt \emph{false} zurück, da der neue Schüler abgelehnt wird. Andernfalls soll der neue Schüler jedoch den alten ersetzen. Hierfür wird dem alten Schüler erst mitgeteilt, dass er kein Geschenk mehr hat. Davor muss geprüft werden, ob es überhaupt einen alten Schüler gibt. Gibt es keinen, hat \emph{studentId} den Standardwert -1, weshalb dieser Fall abgefangen werden muss. Anschließend werden die Werte des neuen Schülers übernommen, ihm wird mitgeteilt, dass er nun ein Geschenk hat und die Methode gibt \emph{true} zurück. Der Algorithmus selbst ist in zwei Phasen unterteilt:
\begin{enumerate}
    \item Jeder Schüler versucht seinen Erstwunsch zu bekommen.
    \item Jeder Schüler fragt pro Durchlauf ein Geschenk, dass er noch nicht versucht hat, an. Hierbei werden nacheinander die Wünsche favorisiert. Sind bereits alle probiert wurden, werden einfach alle restlichen Geschenke versucht.
\end{enumerate}
Phase 1 findet nur beim ersten Durchlauf durch alle Schüler statt. Danach wird in Phase 2 übergegangen und solang über alle Schüler iteriert, bis jeder ein Geschenk bekommen hat. Endet die Schleife, wurde die bestmögliche Verteilung erreicht. Der gesamte Quellcode des Algorithmus ist in Abbildung \ref{AlgWichteln} zu finden.

\begin{figure}[h]
    \centering
\begin{lstlisting}
// Phase 1
for(int i=0; i<students.length; i++) {
    students[i].requestPresent(presents, students, students[i].wishes[0], 0);
}
            
// Phase 2
boolean finished = false;
do {
    // Die Schleife ist prinzipiell immer fertig, außer es wird noch ein Schüler gefunden, der kein Geschenk hat
    finished = true;
    for(int i = 0; i < students.length; i++) {
        if(!students[i].hasGift) {
            finished = false;
            			
            // Es wird versucht, einen der Wünsche zu erfüllen
            if(!students[i].asked[students[i].wishes[0]]) {
            	students[i].requestPresent(presents, students, students[i].wishes[0], 0);
            } else if(!students[i].asked[students[i].wishes[1]]) {
            	students[i].requestPresent(presents, students, students[i].wishes[1], 1);
            } else if(!students[i].asked[students[i].wishes[2]]) {
            	students[i].requestPresent(presents, students, students[i].wishes[2], 2);
            } else {
                // Da bereits alle Wünsche probiert wurden, wird versucht irgendein Geschenk zu bekommen
            	for(int j = 0; j < presents.length; j++) {
            	    if(!students[i].asked[j]) {
            	        students[i].requestPresent(presents, students, j, 3);
            	    }
                }
            }
        }
    }
} while(!finished);
    \end{lstlisting}
    \caption{Die Implementierung des Algorithmus\label{AlgWichteln}}
\end{figure}

\subsection{Beispiele}

Anhand eines selbsterstellten, kleinen Beispiels wird hier die Funktion des Algorithmus dargestellt. Anschließend werden alle Ergebnisse der vorgegebenen Beispielaufgaben aufgeführt.

\begin{table}[ht]
\centering

\begin{tabular}{@{}cccc@{}}
\toprule
Schüler & Erstwunsch & Zweitwunsch & Drittwunsch \\ \midrule
A       & 1          & 2           & 3           \\
B       & 2          & 3           & 4           \\
C       & 2          & 1           & 4           \\
D       & 4          & 1           & 3           \\ \bottomrule
\end{tabular}

\caption{Beispielhafte Verteilung der Wünsche\label{BeispielWichteln}}
\end{table}

Zuerst wird das Beispiel aus Tabelle \ref{BeispielWichteln} vom Programm eingelesen. Dabei wird für jeden Schüler, sowie für jedes Geschenk ein Objekt erstellt. Danach beginnt der Algorithmus direkt mit der Verteilung der Geschenke. Im ersten Durchlauf versucht jeder Schüler seinen Erstwunsch zu bekommen. Die Schleife beginnt mit Schüler A. Da sein Erstwunsch frei ist, bekommt er Geschenk 1 zugeteilt. Dasselbe passiert bei Schüler B, dieser bekommt folglich Geschenk 2 zugeteilt. Der Erstwunsch von Schüler C ist bereits vergeben und da C es mit einem Erstwunsch haben will, es aber bereits an einen Erstwunsch vergeben ist, wird Schüler C abgelehnt. Schüler D bekommt Geschenk 4 als Erstwunsch zugeteilt. Jetzt wird in Phase 2 gewechselt. Schüler A und B werden übersprungen, da beide bereits ein Geschenk haben. Schüler C hat seinen Erstwunsch bereits angefragt und probiert deshalb jetzt seinen Zweitwunsch. Dieser ist ebenfalls bereits vergeben und da Schüler C mit einem Zweitwunsch anfragt, wird er abgelehnt. D wird ebenfalls übersprungen. Im nächsten Durchlauf wird ebenfalls jeder außer C übersprungen. Dieser fragt nun seinen Drittwunsch an, welcher bereits an einen höheren Wunsch vergebenen ist. Somit beginnt erneut ein neuer Durchlauf der Schleife, bei dem C nun irgendein Geschenk, das er noch nicht probiert hat, versucht. Es bleibt nur Geschenk 3 übrig, welches er zugeteilt bekommt. Damit wurde jedem Schüler ein Geschenk zugeteilt. Die ausgegebene Verteilung lässt sich Tabelle \ref{WichtelnErgebnis} entnehmen.

\begin{table}[ht]
    \centering
\begin{tabular}{@{}cc@{}}
\toprule
\multicolumn{1}{l}{Schüler} & \multicolumn{1}{l}{Geschenk} \\ \midrule
A                           & 1                            \\
B                           & 2                            \\
C                           & 3                            \\
D                           & 4                            \\ \bottomrule
\end{tabular}

    \caption{Das Ergebnis des Programms\label{WichtelnErgebnis}}
\end{table}
%\begin{linenumbers}\resetlinenumber
%\end{linenumbers}

\end{document}
